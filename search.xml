<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Hexo静态博客之整体搭建流程</title>
      <link href="/post/10061.html"/>
      <url>/post/10061.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><p>静态博客框架 Hexo 的基本原理：使用特定的主题，将以 Markdown 语法编写的文章转为 HTML 文件，并配合一些 CSS 和 JS 文件，一起部署到服务器上（当然也不一定非是服务器，现在有很多提供静态网站托管的第三方 Pages 服务，比如 Github Pages 和 Gitee Pages），最后用户通过访问这些静态资源来访问博客网站！</p><p>Hexo 博客的整体搭建流程主要分为下面三步：</p><ul><li>第一步：本地安装，在本地安装 Hexo 程序，是用来生成和管理静态资源的；</li><li>第二步：远程部署，将本地静态资源部署到静态资源托管平台或者服务器上；</li><li>第三步：绑定域名（非必要），绑定域名后，可以实现使用域名直接访问博客（逼格拉满）；</li></ul><p>我这篇博文就是详细记录如何从零开始搭建一个基本可以使用的 Hexo 博客网站，网站是部署在 Github 上的，不包括博客网站的基本设置（关于网站的主题替换、外观美化、性能优化等操作，我会在后续的几篇博文中详细记录和说明）。</p><p>友情提示：该系列的 Hexo 博客搭建文章记录的都比较详细，主要是为了照顾一些零基础的小伙伴，此外对一些基本概念性的内容进行了详细解释和我的一些个人理解（包括但不局限于 Github 和 Gitee 的对比、使用 Git 推送的注意项、域名的解析配置等），对于一些有计算机基础的小伙伴可以自行跳跃查看！</p><h1 id="第二节：本地安装"><a href="#第二节：本地安装" class="headerlink" title="第二节：本地安装"></a>第二节：本地安装</h1><h2 id="2-1：前提条件"><a href="#2-1：前提条件" class="headerlink" title="2.1：前提条件"></a>2.1：前提条件</h2><p>在本地安装 Hexo 程序，首先需安装 Git 和 Nodejs，安装 Git 有两个用处：</p><ol><li><p>在使用 hexo-cli 初始化本地 Hexo 程序文件时，会默认使用 Git 从 Github 下载 Hexo 程序源文件；</p></li><li><p>本地安装 Hexo 程序后，还需要使用 Git 将本地 Hexo 生成的静态博客文件上传到服务器或代码托管平台；</p></li></ol><p>安装 Nodejs 也有两个用处：</p><ol><li><p>Hexo 程序是基于 Nodejs 的，Hexo 的运行要依赖 Nodejs 环境；</p></li><li><p>Nodejs 自带的 npm 是安装 hexo-cli 的工具，而且后续 Hexo 程序需要的插件都要依赖 npm 下载；</p></li></ol><p>关于 Git 和 Nodejs 的介绍、安装和使用，不是这篇博文的重点，本身也很简单，我这里就不赘述了~~</p><h2 id="2-2：全局安装-hexo-cli"><a href="#2-2：全局安装-hexo-cli" class="headerlink" title="2.2：全局安装 hexo-cli"></a>2.2：全局安装 hexo-cli</h2><blockquote><p>hexo-cli 是一个 npm 软件包，封装了一些命令，它并不是 Hexo 程序，安装完 hexo-cli 后，再通过它来安装 Hexo！</p></blockquote><p><font color='red'>安装 hexo-cli 一定要使用全局安装</font>！只有这样，我们才可以在本机的任何目录都能使用 hexo-cli，这样我们就可以自由地选择在哪个目录下初始化我们的 Hexo 程序（就可以任意选择将我们的博客工程放在哪个目录下）！</p><p>打开终端，执行如下命令来全局安装 hexo-cli：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完成以后使用命令<code>npm list -g</code>查看是否安装成功：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021173638924.png"></p><p>成功安装后会在<code>/usr/local/bin/</code>目录中创建名为<code>hexo</code>的软链接并指向<code>hexo-cli/bin</code>下面的<code>hexo</code>命令：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021174400442.png"></p><p>因为<code>/usr/local/bin</code>目录在系统环境变量 PATH 里面，因此此时我们可以在任意目录下直接执行这里的<code>hexo</code>命令，并且这个命令就是我们前面全局安装的<code>/usr/local/lib/node_modules/npm-cli.js</code>！这就是为什么我们一定要全局安装 hexo-cli 的原因！</p><h2 id="2-3：下载安装-Hexo"><a href="#2-3：下载安装-Hexo" class="headerlink" title="2.3：下载安装 Hexo"></a>2.3：下载安装 Hexo</h2><blockquote><p>初始化 Hexo 可以理解为下载 Hexo 程序，也就相当于安装了一个免安装的程序，类似于安装 Maven 一样。</p></blockquote><p>打开终端，切换到你想安装 Hexo 程序（博客工程）的目录下，执行如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init 自定义文件夹名</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这里使用的<code>hexo</code>命令是前面安装的<code>hexo-cli</code>包中自带的命令，也就是<code>/usr/local/bin/hexo</code>；</li><li>执行这条命令时，计算机会使用 Git 从 Github 上下载 Hexo 程序到本地（所以之前一定要先安装 Git）；</li><li>下载下来的 Hexo 程序会被重命名为命令中指定的文件夹名称，这个目录就是博客工程的根目录；</li></ul><p>比如我打算把博客工程直接放在我的桌面上，并将其命名为<code>MyBlogs</code>，那么就这么操作：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021174859408.png"></p><p>命令执行成功以后，就会在桌面生成名为<code>MyBlogs</code>的文件夹，其初始内容如下：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021174945457.png"></p><p><font color=red><strong>注意</strong></font>：从现在开始，我们再使用<code>hexo</code>命令，就要切换到博客根目录下，否则使用的依然是<code>/usr/local/bin/hexo</code>，也就是<code>/usr/local/bin/hexo</code>（2.2 中全局安装的<code>hexo-cli</code>中的<code>hexo</code>命令），会发生意料之外的错误！</p><p>然后，切换到本地博客工程根目录下，执行<code>hexo --version</code>来查看安装的 Hexo 和 Nodejs 的版本信息：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021175105119.png"></p><p>此外，刚下载的 Hexo 程序，其中自带的 npm 包如下：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021175202989.png"></p><h2 id="2-4：本地预览-Hexo"><a href="#2-4：本地预览-Hexo" class="headerlink" title="2.4：本地预览 Hexo"></a>2.4：本地预览 Hexo</h2><blockquote><p>安装了 Hexo 程序后，我们就可以使用它来生成静态博客文件了，也可以在本地预览此时的博客是什么样子的</p></blockquote><p>打开终端，切换到本地博客工程根目录下，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server  # 也可简写成&quot;hexo s&quot;</span><br></pre></td></tr></table></figure><p>执行成功时，终端中应该是这个样子：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021175253054.png"></p><p>此时不要关闭终端，接着打开浏览器访问<code>http://localhost:4000/</code>，可以看到此时博客的样子：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021175504507.png"></p><p>这就是目前本地的 Hexo 程序生成的博客网站的样子！若想停止预览，可在之前的终端窗口中用快捷键<code>Ctrl</code>+<code>C</code>来停止。</p><p>友情提示：此时 Hexo 博客网站使用的是默认的主题<code>landscape</code>，并且在博客工程根目录下的<code>source/_post/</code>中下有一篇默认的博文《hello-world.md》，也就是上图中展示的这篇博文！</p><h1 id="第三节：远程部署"><a href="#第三节：远程部署" class="headerlink" title="第三节：远程部署"></a>第三节：远程部署</h1><p>经过第一步，我们已经在本地安装了 Hexo 程序，并可以在本地通过浏览器来预览我们的博客网站了。但是要想让其他人也能看到这个博客网站的话，就需要将本地生成的静态博客资源部署到静态资源托管平台或者服务器上！</p><h2 id="3-1：我的选择"><a href="#3-1：我的选择" class="headerlink" title="3.1：我的选择"></a>3.1：我的选择</h2><p>部署静态博客网站，目前只有两个选择，一是服务器，二是静态资源托管平台。关于如何选择部署平台，可以参考我之前发布的一篇文章—-<a href="https://www.fattymonkey.com/post/10042.html">《静态博客托管平台》</a>。其中详细描述了各种不同部署平台以及它们的优劣，我选择使用 Github 来做演示，因为 Gitee 的各种实名认证是真的逃也逃不掉，这是由国内的政策决定的，而且完成这些实名认证不仅费时，还费财（网站备案需要购买一台云服务器，真无语）！而 Github 建站简单、维护简单、完全免费（只需要自己购买域名，配套的 Vercel 也是免费的）！相比之下，选哪个比较合适不言而喻。</p><h2 id="3-2：创建仓库"><a href="#3-2：创建仓库" class="headerlink" title="3.2：创建仓库"></a>3.2：创建仓库</h2><p>首先，你需要注册 Github 账号，并创建一个仓库：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818202939395.png"></p><p><font color='red'>友情提醒</font>：</p><ul><li>仓库名称建议使用<code>username.github.io</code>的形式，这样最后生成的博客网站的网址最简洁，当然你也可以使用其他的名称，但是不仅最后生成的网址不够简洁，而且在在对你的网站进行个性化设置的时候，还会出现各种和路径相关的问题，最常见的就是加载不到网站的 CSS 和 JS 文件，所以，强烈建议这种命名方式，这里的 username 指的是你的 Github 的用户名；</li><li>仓库必须选择 Public，公开的意思仅仅是公开给别人看和下载，假如别人想要提交代码到你的仓库，是需要经过你的同意的，不用担心自己的博客被别人修改；</li><li>建议添加 README 文件，不然后续你在 Github 网页查看自己的仓库时，总会有要你添加该文件的提示；</li><li>不需要添加<code>.gitignore</code>文件，因为 Hexo 程序生成的静态文件中就有这个文件，后续我们可以将这个文件上传到这个仓库，所以压根就不需要在创建仓库的时候添加这个文件；</li><li>建议在创建仓库的时候就直接添加一个开源许可证，不添加也没什么关系；</li><li>此时创建的仓库的默认分支是 main，而不是 master；</li></ul><p>点击创建以后，就创建了一个仓库，仓库中只有 Readme 文件和开源许可证：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818203601586.png"></p><h2 id="3-3：创建口令"><a href="#3-3：创建口令" class="headerlink" title="3.3：创建口令"></a>3.3：创建口令</h2><p>后面我们需要将本地生成的静态博客资源上传到这个仓库，从 2021 年 8 月 13 日开始，Github 就不再接受用户名和密码这种形式的验证了，转而接受用户名和口令（token）！</p><p>关于这一部分的内容，可以参考我的这篇博文—-<a href="https://www.fattymonkey.com/post/10021.html">《Github使用口令替代密码来进行上传验证》</a>，这篇博文中详细描述了口令的创建和使用注意事项，在这里我就不再赘述了！</p><h2 id="3-4：部署插件"><a href="#3-4：部署插件" class="headerlink" title="3.4：部署插件"></a>3.4：部署插件</h2><p>使用 Git 可以将 Hexo 静态博客文件上传到服务器，此外 Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上，一键部署依赖插件 <a href="https://github.com/hexojs/hexo-deployer-git">hexo-deployer-git</a>。</p><p>第一步：在本地安装这个插件。打开终端，切换到博客工程根目录下，执行如下安装命令</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>比如我的安装情况：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021175938349.png"></p><p>第二步：配置插件。打开博客工程根目录下的<code>_config.yml</code>文件，找到<code>deploy</code>并进行如下配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: https://hexo.io/docs/one-command-deployment</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/fattymonkey/fattymonkey.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>Hexo 的官网上对这里的配置描述的很清楚：</p><ul><li>type：上传方式，hexo-deployer-git 插件支持 Git 上传，所以这里配置为 Git；</li><li>repo：仓库地址，没有默认值，必须要配置为自己的仓库；</li><li>branch：分支名称，现在在 Github 上的仓库，默认主分支是 main，不再是 master；</li><li>message：自定义提交信息，因为每次提交设置的提交信息都应该不同，所以不在这里配置死；</li><li>token：可选的口令值，用于认证 repo，用<code>$</code>作为前缀从而从环境变量中读取令牌（即3.3中生成的口令）；</li></ul><p>注意：建议只配置<code>type</code>、<code>repo</code>、<code>branch</code>这三项，这三项是必填项，<code>token</code>可以没必要配置，第一次我们提交静态资源到仓库时，使用输入的方式来验证以后，token 会缓存到你的电脑上，也不再需要验证了，所以压根不用在这里配置，而且还容易造成口令泄露，存在安全隐患！</p><h2 id="3-5：配置文件"><a href="#3-5：配置文件" class="headerlink" title="3.5：配置文件"></a>3.5：配置文件</h2><p>假如此时我们在本地生成静态资源文件并上传到仓库，那么 Github 仓库中原本存在的两个文件就会被覆盖掉！为了让它们不被覆盖掉，我们需要将它们下载下来放到本地博客工程根目录下的<code>/source</code>目录中：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818204519199.png"></p><p>但是这样还不够！因为 Hexo 程序会将所有的 Markdown 文件渲染为 html 文件，如果我们不做处理的话，这里的 readme 文件会被渲染为 html 文件，但是我们并不想让它把 readme 文件也渲染，Hexo 程序考虑到了这种情况，只要我们在程序根目录下的<code>_config.yml</code>文件中，进行如下配置：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818205005468.png"></p><p>这样配置<code>skip_render</code>的值以后，Hexo 在渲染时，就会跳过这个文件，而文件<code>LICENSE</code>本身就不会被渲染！</p><h2 id="3-6：生成文件"><a href="#3-6：生成文件" class="headerlink" title="3.6：生成文件"></a>3.6：生成文件</h2><p>打开终端，切换到博客根目录下，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  # 修改了_config.yml文件后，要想生效就要清理缓存，也可以简写为&quot;hexo cl&quot;</span><br><span class="line">hexo generate  # 执行程序，渲染文件，也可以简写为&quot;hexo g&quot;</span><br></pre></td></tr></table></figure><p>这个命令还有其他的一些参数，官网上写的很明白：</p><ul><li><code>-d</code>或<code>--deploy</code>：文件生成后立即部署网站；</li><li><code>-w</code>或<code>--watch</code>：监视文件变动；</li><li><code>-b</code>或<code>--bail</code>：生成过程中如果发生任何未处理的一场则抛出异常；</li><li><code>-f</code>或<code>--force</code>：强制重新生成文件，Hexo 引入了查分机制，如果<code>public</code>目录存在，那么<code>hexo g</code>只会重新生成改动的文件；</li><li><code>-c</code>或<code>--concurrency</code>：最大同时生成文件的数量，默认无限制；</li></ul><p>比如我的执行情况是：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20231021180503857.png"></p><p><font color='red'>注意</font>：</p><ul><li>执行以后，博客根目录下就生成了<code>/public</code>文件夹，其中的文件就是要推送到仓库中的内容；</li><li><code>/public</code>文件夹中此时会生成名为<code>index.html</code>的文件，上传到仓库以后，我们就能访问博客网站了；</li><li>执行<code>hexo generate</code>后，不仅会生成 public 文件夹，还会生成名为<code>db.json</code>的缓存数据文件；</li></ul><h2 id="3-7：上传仓库"><a href="#3-7：上传仓库" class="headerlink" title="3.7：上传仓库"></a>3.7：上传仓库</h2><p>生成了静态博客文件以后，我们就可以使用如下命令来将它们上传到 Github 仓库（在本地博客根目录下执行）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy  # 也可以简写成&quot;hexo s&quot;</span><br></pre></td></tr></table></figure><p>按下回车，假如你是第一次往你的 Github 仓库上传代码，需要你输入用户名和密码（密码是在 3.3 中生成的口令）！</p><p>上传成功后，仓库中的内容如下：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818205636053.png"></p><h2 id="3-8：访问博客"><a href="#3-8：访问博客" class="headerlink" title="3.8：访问博客"></a>3.8：访问博客</h2><p>此时，就可以使用地址<code>https://username.gitee.io</code>来访问博客了！</p><h1 id="第四节：部署-Vercel"><a href="#第四节：部署-Vercel" class="headerlink" title="第四节：部署 Vercel"></a>第四节：部署 Vercel</h1><p>经过前面的操作，此时我们已经可以用网址<code>https://username.github.io</code>来访问我们的博客了，但是现在有一个很严重的问题，就是访问速度！此时我们可以将网站部署到 Vercel 上，它可以提供全局的公共 CDN 加速服务！</p><h2 id="4-1：注册账号"><a href="#4-1：注册账号" class="headerlink" title="4.1：注册账号"></a>4.1：注册账号</h2><p>关于这部分内容，可以参考我的这篇博文—-<a href="https://www.fattymonkey.com/post/10023.html">《Github + Vercel 搭建免费的个人图床》</a>，其中的 3.2.1 详述了如何注册 Vercel 账号！</p><h2 id="4-2：部署仓库"><a href="#4-2：部署仓库" class="headerlink" title="4.2：部署仓库"></a>4.2：部署仓库</h2><p>进入 Vercel 控制面板，点击页面的<code>Create a New Project</code>，在<code>Import Git Repository</code>处选择博客仓库：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818210319751.png"></p><p>点击上面博客仓库对应的<code>import</code>按钮后，接着直接点击下图中的<code>Deploy</code>部署按钮：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818210551466.png"></p><p>稍等片刻，就能看到部署成功的提示（撒花庆祝）：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818210800222.png"></p><h2 id="4-3：访问博客"><a href="#4-3：访问博客" class="headerlink" title="4.3：访问博客"></a>4.3：访问博客</h2><p>部署成功以后，Vercel 会给我们的网站自动分配一个个性化域名，点击上图中的<code>Continue to Dashboard</code>进入控制台：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818211055825.png"></p><p>上图红框内的内容，就是 Vercel 分配给我们的个性化域名，通过这个域名就可以访问我们的博客网站了！</p><p>由于<code>.vercel.app</code>这个域在国内被墙了，所以假如你在国内，此时通过 Vercel 分配的这个域名是访问不到博客网站的！</p><h1 id="第五节：配置域名"><a href="#第五节：配置域名" class="headerlink" title="第五节：配置域名"></a>第五节：配置域名</h1><p>此时，我已经拥有了一个可以使用<code>fattymonkey.github.io</code>和<code>fattymonkey-github-io.vercel.app/</code>这两个域名来访问的博客网站，由于<code>.vercel.app</code>这个域在国内被墙了，所以假如你在国内，此时通过 Vercel 分配的这个域名是访问不到博客网站的！</p><p>域名可以通过域名解析配置到两个不同的地方，此时我们可以选择将我们的域名解析到如下两个地方：</p><ul><li>解析到 Github Pages 仓库，这样通过域名来访问时，实际上还是访问的 Github Pages；</li><li>解析到 Vercel 分配给我们的域名上，这样就能解决 Vercel 域名在国内被墙的问题；</li></ul><p>因为 Vercel 具备全局加速的 CDN 服务，所以我们当然是将域名解析到 Vercel 上了啊！</p><h2 id="5-1：购买域名"><a href="#5-1：购买域名" class="headerlink" title="5.1：购买域名"></a>5.1：购买域名</h2><p>建议在腾讯云购买域名，价格较便宜的同时，还可附赠 DNSPod（用来配置域名解析），即使是老用户，也可以在购买域名的同时加购 DNSPod，总体而言还是比较优惠的。</p><p>至于如何购买域名，就不废话了，自行登录腾讯云官网查看购买，官方文档的描述很详细！</p><h2 id="5-2：配置解析"><a href="#5-2：配置解析" class="headerlink" title="5.2：配置解析"></a>5.2：配置解析</h2><p>打开 Vercel 博客项目的控制台：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818211659989.png"></p><p>点击右上角的<code>Domains</code>，将自己购买的域名填入（填入二级域名，也就是主域名），比如我的：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818212515262.png"></p><p>然后点击<code>Add</code>按钮，接着在弹窗中点击<code>Add</code>：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818212725654.png"></p><p>添加成功后，发现当前的解析记录是无效的：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818213353915.png"></p><p>因为我们自己购买的域名现在还没有解析到 Vercel，打开你的域名解析，按照上面提示添加两条解析记录：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818213644868.png"></p><p>待解析生效，Vercel 还会自动帮我们生成 SSL 证书，生成以后，显示当前域名添加完成：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818213824474.png"></p><p>此时，你就可以用你自己的域名来访问博客网站了（使用<code>fattymonkey.com</code>或<code>www.fattymonkey.com</code>都可以）！</p><h1 id="第六节：写在后面"><a href="#第六节：写在后面" class="headerlink" title="第六节：写在后面"></a>第六节：写在后面</h1><h2 id="6-1：发布流程"><a href="#6-1：发布流程" class="headerlink" title="6.1：发布流程"></a>6.1：发布流程</h2><p>经过以上的操作，我们就搭建了一个最简单的 Hexo 博客，其他用户可以通过浏览器来访问我们的博客！</p><p>此后，假如我们需要发布博客的话，就创建 Markdown 文件，并将其放到博客工程根目录下的<code>/source/_posts</code>中，然后依次执行如下两个命令，就可以完成博文的发布：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br><span class="line">hexo deploy</span><br></pre></td></tr></table></figure><p>注意，除了这种方式，我们还有三种命令，可以将生成静态博文件和推送合并成一步：</p><ul><li><code>hexo generate &amp;&amp; hexo deploy</code>；</li><li><code>hexo generate -deploy</code>；</li><li><code>hexo deploy -generate</code>；</li></ul><p>PS：上述的每个<code>deploy</code>都可以用<code>d</code>来替代，每个<code>generate</code>都可以用<code>g</code>替代；</p><p>此时博客工程根目录下的<code>/source/_post/hello-word.md</code>文件就可以删除了，然后自己创建一个 Markdown 的文件替换它即可。比如我写了一篇，名为<code>first-test.md</code>，内容如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 博客搭建成功</span><br><span class="line">date: 2023-03-01 06:43:58</span><br><span class="line">updated: 2023-08-18 21:42:05</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">我的 Hexo 博客搭建成功了，这是一篇用来做测试博文</span><br><span class="line"></span><br><span class="line"># 标题一</span><br><span class="line"></span><br><span class="line">&gt; 这是一段引用文本</span><br><span class="line"></span><br><span class="line">下面是一段 Python 代码：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">myStr = &#123;&#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;&#125;</span><br><span class="line">    for i in myStr:</span><br><span class="line">        print(i)</span><br><span class="line">```</span><br><span class="line"></span><br><span class="line">显示一个微笑的emoji表情：:smile:</span><br></pre></td></tr></table></figure><p>然后打开终端，切换到本地博客根目录下，执行发布命令，即可完成博文的发布：</p><p><img src="https://www.czblogs.cn/posts/hexo/01/image-20230818214804298.png"></p><h2 id="6-2：后续优化"><a href="#6-2：后续优化" class="headerlink" title="6.2：后续优化"></a>6.2：后续优化</h2><p>到现在为止，我们已经有了一个可以基本使用的博客网站了，为什么说基本呢？因为此时的 Hexo 博客还需要很多很多的折腾！比如下面这些后续操作：</p><ul><li>更换主题；</li><li>主题的基本配置（永久链接、代码高亮、全局搜索等）；</li><li>主题的功能配置（评论系统等）；</li><li>主题美化；</li><li>性能优化；</li></ul><p>这些内容都会在我后续的博文中详细介绍！</p>]]></content>
      
      
      <categories>
          
          <category> 静态博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vercel </tag>
            
            <tag> Hexo </tag>
            
            <tag> GitHub </tag>
            
            <tag> 域名解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客框架该怎么选</title>
      <link href="/post/10043.html"/>
      <url>/post/10043.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><p>这篇博文是我搭建个人博客系列的第一篇，本文没有记录任何搭建博客的实际操作，旨在分析当下几种流行的博客平台和博客框架，包括第三方博客平台以及各种博客框架的优势和缺点，如果你还没有拥有自己的博客网站，并且从现在开始想做一个属于自己的博客网站的话，那么这篇博文应该会对你有所帮助。</p><p>特别提示：本文提及的博客框架很多，其中有一些我自己也没有用过，对于我没使用过的这些框架，主要是参考了大神我不是咕咕鸽的<a href="https://blog.laoda.de/archives/blog-choosing/">这篇文章</a>。</p><h1 id="第二节：博客是什么"><a href="#第二节：博客是什么" class="headerlink" title="第二节：博客是什么"></a>第二节：博客是什么</h1><p>博客正式名称为网络日记，又音译为部落格或部落阁等。博客（英语：Blog）是一种在线日记形式的个人网站，借由张贴文章、图片或视频来记录生活、抒发情感或分享信息。</p><p>到现在为止，博客的形式更加具体化，博客网站的内容会大部分偏向于某个方面，比如程序员分享技术、数码博主分享数码产品体验和测评、个人或平台分享美食和美妆等等。在博客平台上，博主不仅可以分享自己，还可以跟志同道合的人互动交友、交流交换信息。尤其像我这种程序员，个人博客就显得尤为重要了。首先我可以将博客作为自己的个人笔记来使用，程序员每天都要学习新的东西，并且学习的知识点多而且杂，经常为了完成某个需求而在网络上苦苦需求大半天，而找到的结果可能用一次就不会再用了，这种情况下我就需要一个类似“个人笔记”的东西来记录，个人博客就是一个很优秀的个人笔记！其次，由于博客是在线的，只要有网络的地方就可以访问，这相比于实体的存储设备具备更大的灵活性；而且，博客是分享自己是最直接的方式，学习是没有止境的，但是学习的最终形态就是输出！此外，博客平台一般具备评论系统，我们可以借助评论系统来进行沟通交流，也促进了自己个人的进步；最后，假如哪天你想要换一份工作，一个优秀的个人网站也会给你的面试添彩不少！</p><p>总而言之，在当下信息爆棚的时代，拥有一个个人博客，是一件很有必要也很有意义的事情！</p><h1 id="第三节：第三方平台"><a href="#第三节：第三方平台" class="headerlink" title="第三节：第三方平台"></a>第三节：第三方平台</h1><p>即使你从来没有写过博客，你肯定也接触过别人写的博客！当你用浏览器搜索时，经常会在搜索结果中看到一些博客的链接，比如简书、博客园、CSDN、知乎等等。这些都是第三方平台，它们的用户在这些平台上发布自己的博文。使用这些第三方平台来写博客是很简单的，你只需要在这些平台上注册一个账号，然后就可以直接使用它们提供了服务了，发布文章、评论文章以及回复评论等，全部在平台上来实现，甚至不用花一分钱！</p><p>曾经我也是使用第三方平台来写自己的技术博客的，知乎、CSDN、博客园等我都用过，但是在我身上发生过好几次这样的事情，就是我经常会发现我之前写的博文莫名其妙被删除了，给我的理由是包含违规内容之类的，实际上存不存在违规内容不知道，反正我辛辛苦苦写的博文就这么莫名其妙地没了！</p><h1 id="第四节：自建的博客"><a href="#第四节：自建的博客" class="headerlink" title="第四节：自建的博客"></a>第四节：自建的博客</h1><p>对于喜欢折腾的人来说，自己搭建一个博客网站会是更好的选择，不仅可以避免第三方博客平台存在的问题，还可以定制化自己的网站，更好的展示自己！由于很多编程技术和博客框架技术的进步，现在搭建自己的个人博客已经没有那么高的要求了，对于没有编程经验的人来说，甚至半个小时就能搭建出一个属于自己的网站。</p><p>从大的方面来讲，现在主流的博客框架分为两种：</p><ul><li>静态博客框架：静态博客网站就是由一些 HTML、CSS、JS 等前端资源组成的，这些静态资源部署在代码托管平台或者服务器上，当访客访问博客网站时，浏览器从服务器直接获取这些静态资源，然后展示给访客。</li><li>动态博客框架：动态博客才是实质意义上的网站，不仅有前端资源，还有后台数据库等资源，当用户访问时，获取的数据来自数据库，而浏览器则负责前端页面的渲染；</li></ul><p>当下最流行的博客网站有下面五种，现在我们来简单说一下这五种博客框架的优缺点。</p><h2 id="3-1：Hexo"><a href="#3-1：Hexo" class="headerlink" title="3.1：Hexo"></a>3.1：Hexo</h2><ul><li><p><strong>优点</strong></p><p><font color=red>静态博客网站</font>。它是基于 Nodejs 的，使用特定的主题将 Markdown 文件渲染成静态的博客网站文件，然后通过命令将静态博客文件上传到服务器，以此来完成博客网站的部署，快速且优雅；</p><p><font color=red>建站成本很低</font>。Hexo 是静态博客网站，其原理就是把生成的静态博客文件上传到服务器，所以可以将博客部署到 Github 或 Gitee 上，不用另外花钱购买服务器，当然你也可以自己购买服务器来部署；</p><p><font color=red>使用的人很多</font>。假如你遇到了问题去网上搜解决方案的话，也是比较容易的。而且 Hexo 是台湾人开发的，中文文档非常友好；</p></li><li><p><strong>缺点</strong></p><p><font color=red>没有后端</font>！因为没有后端，所以静态博客存在很多天生的弊端。第一，博客部署完成以后，一旦你换了一台电脑，就不得不重新部署环境，而且你需要拷贝你的博客在云端，否则你配置好新的电脑并推送过去的话，你之前写的博客就都没了；第二，因为没有后端，所以基本上你只能在本地写文章，假如你的电脑不再身边，就没办法写文章并发布了（不过现在可以将 Hexo 程序部署到服务器 Docker 上，可以在线写文章）；第三，没有后端就意味着没有数据库，那么博客的评论系统必须外接其他平台，你需要从它们当中选一个来配置。我总担心评论数据会丢失，之前还暴出大家用的很多的 Valine 存在安全问题，总之评论系统的配置还是比较繁琐的！第四，Hexo 博客依赖于 theme 和 plug，如果想做出满意的博客网站，肯定需要很大的折腾，而且如果你想做出满意的效果，就要具备一些前端的编程技术，越想搞好难度就越高；</p></li><li><p><strong>总结</strong></p><p>如果你愿意折腾的话，Hexo 是我最推荐的，如果你有时间折腾，一定要玩一玩 Hexo，还能学到很多知识！</p></li></ul><h2 id="3-2：Hugo"><a href="#3-2：Hugo" class="headerlink" title="3.2：Hugo"></a>3.2：Hugo</h2><ul><li><p><strong>优点</strong></p><p>跟 Hexo 一样，Hugo 也是静态博客网站，也具备静态博客天生的缺点，但是它比 Hexo 更简单一些！而且它是用 Go 语言写的，如果你有几百篇 Markdown 的文章要渲染，它可以在几秒钟的时间就完成渲染，而 Hexo 则可能需要更长的时间；</p></li><li><p><strong>缺点</strong></p><p>使用 Hugo 的人比 Hexo 的人少很多，相对可用的主题也比较少，如果你遇到问题去网上查找解决方案的话，可能有找不到解决方案的风险，或者需要很长的时间！</p></li><li><p><strong>总结</strong></p><p>同 Hexo，如果你爱折腾，而且你的文章有很多（几百篇的样子），那么我还是比较推荐你使用 Hugo 的。虽然可用的主题比较少，但是依然有一些简约美观的主题可以选择。</p></li></ul><h2 id="3-3：Typecho"><a href="#3-3：Typecho" class="headerlink" title="3.3：Typecho"></a>3.3：Typecho</h2><ul><li><p><strong>优点</strong></p><p><font color=red>非常轻量</font>，整个文件才385KB，而且到我写博文的时间，还在一致不断地更新优化；</p><p><font color=red>带有后端</font>，因为带有后端，所以假如你换了一台电脑，就不需要重新部署，可以直接登录后端来写博客；</p></li><li><p><strong>缺点</strong></p><p><font color=red>需要购买服务器</font>；</p><p><font color=red>可扩展性也有限</font>。对于单纯的博客来说，这个问题其实不是问题，说它扩展性有限是因为跟 Wordpress 相比。</p></li><li><p><strong>总结</strong></p><p>对于只是想写博客，不想搞花里胡哨的人，而且服务器配置有限的话，那我推荐使用 Typecho！</p></li></ul><h2 id="3-4：Halo"><a href="#3-4：Halo" class="headerlink" title="3.4：Halo"></a>3.4：Halo</h2><ul><li><p><strong>优点</strong></p><p><font color=red>部署和维护方便</font>，因为可以使用 Docker 来部署和维护；</p><p><font color=red>日渐丰富的主题</font>；</p><p><font color=red>活跃的社区</font>，开发者非常友好，基本上你碰到任何问题，都能在社区中找到答案；</p></li><li><p><strong>缺点</strong></p><p>Halo 是使用 Java 编写的，所以比较迟服务器的配置；</p></li><li><p><strong>总结</strong></p><p>如果你有一台配置不错的服务器，那么你真的要试一下 Halo！你会发现它真的是太省心了，与 Hexo 和 Hugo 相比，它自带了后端，你随时随地都可以发布文章（只要有网络和浏览器）；与 Typecho 相比，你不需要去下载邮件插件等一系列插件，Halo 都贴心地给你集成好了，你只需要简单的几个设置就可以使用；如果你想换主题，也可以轻松地利用远程下载，一键换成新主题，非常方便；你还可以随时利用博客自带的备份功能来备份你博客的所有数据，并把他们下载到你的本地；当 Halo 更新了，你也可以利用 docker 在 10s 钟内就完成博客的升级……</p><p>总之，假如你有一台配置不错的服务器，那就选 Halo 吧！</p></li></ul><h2 id="3-5：WordPress"><a href="#3-5：WordPress" class="headerlink" title="3.5：WordPress"></a>3.5：WordPress</h2><ul><li><p><strong>优点</strong></p><p><font color=red>用的人极多</font>。截至 2019 年 10 月的统计，全球所有网站中，有超过 34.7% 的网站采用 WordPress 方式搭建，也就是说每 3 个就有 1 个是用 WordPress 搭建的，小到一个个人博客，大到美国白宫官方网站。你遇到的 99.9% 的问题，世界上其他人肯定都遇到过，所以你可以比较容易在网上找到解决方案。Wordpress 不仅仅可以搭博客，它还可以搭一个论坛，它甚至还可以搭一个商城。</p><p><font color=red>生态丰富</font>。适配的插件非常多，你能想到的功能，99.9% Wordpress 都有，利用庞大的插件库，你可以完成你对网站的一切幻想。</p></li><li><p><strong>缺点</strong></p><p><font color=red>需要服务器</font>；</p><p><font color=red>臃肿</font>。由于功能过于强大，Wordpress 与上面几个博客框架相比，显得非常臃肿，尤其是当你的博客内容多了之后，需要你有一定的网站优化能力（当然这个可以慢慢学，也有很多插件可以帮上忙）</p></li><li><p><strong>总结</strong></p><p>如果你有一台配置不错的服务器，实际上我也不建议使用 Wordpress，因为它太臃肿了，我觉得是没必要！</p></li></ul><h1 id="第五节：我的选择"><a href="#第五节：我的选择" class="headerlink" title="第五节：我的选择"></a>第五节：我的选择</h1><p>由于我个人财力有限，现在个人服务器的价格也不便宜，即使你因为新用户特权，可以在一些平台上享受优惠，但是到期后再续费的话，费用也很高！所以我只能从 Hexo 和 Hugo 里面选择，由于我个人又比较爱折腾（<del>主要是因为我本人得了强迫症晚期，哈哈哈</del>），对 Nodejs 和前端又有所了解，所以我就选择了 Hexo！</p><p>我的这个博文系列，从搭建部署到基本设置，再从外观美化到性能优化，全程都是针对 Hexo 博客的！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 技术白话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>静态博客托管平台</title>
      <link href="/post/10042.html"/>
      <url>/post/10042.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：有哪几种博客网站"><a href="#第一节：有哪几种博客网站" class="headerlink" title="第一节：有哪几种博客网站"></a>第一节：有哪几种博客网站</h1><p>拥有属于自己的博客的重要性不言而喻，不管是作为自己的个人笔记来使用，还是说你想要更好地展示自己（<del>比如你想要换工作时</del>），博客都是一个非常不错的选择！</p><p>而且，现在很多人都拥有自己的博客，并且做的都还不错，当我遇到了问题到网上搜索答案的时候，经常能遇到一些颜值高、内容好的个人博客网站。</p><p>从大的方面来区分，目前常见的个人博客有两种。第一种就是借助第三方博客平台，比较有名的有博客园、CSDN、简书、知乎等；第二种就是自建博客网站，就是自己来创建一个博客网站，实现跟博客平台相类似的功能。</p><h2 id="1-1：借助平台"><a href="#1-1：借助平台" class="headerlink" title="1.1：借助平台"></a>1.1：借助平台</h2><p>借助第三方博客平台是成本最小的实现个人博客的途径，你只需要注册一个账号，即可实现写文章、发布文章的基本功能和评论文章等互动功能，你不需要进行任何部署就可以使用！</p><p>第三方平台确实方便，但是跟自建博客网站比起来，它还是具备一些缺点的。比如你的博客页面被插入了广告时，你毫无办法；当你的博文因为一些过于严苛的审核导致被删除了，你只能默默忍受；当你想要定制化自己的主页时，也只能在平台提供的功能下进行筛选，并不能创造……</p><p>其实，上述所有缺点的根本原因是注册第三方平台只是获得了免费的“个人博客空间”，你的博客空间是依赖于平台的，所有的数据也是存在于平台的数据库上的，你只能做平台允许你这个账号的操作，对于你账号权限以外的事情你是没有办法控制的。因此自建博客网站就出来了！</p><h2 id="1-2：动态博客"><a href="#1-2：动态博客" class="headerlink" title="1.2：动态博客"></a>1.2：动态博客</h2><p>第一种自建博客网站的方式就是动态博客。这种方式比较传统，整个博客网站至少包含数据库、后台管理系统、前台页面展示这三个部分。由于所有的数据都是存在自己的数据库中的，数据经过前端技术的渲染后呈现给访客，呈现的内容会根据数据库返回内容的变化而变化，即动态变化，所以通常我们也将这种传统的自建博客网站称为“动态博客”。</p><p>现在也有很多优秀且成熟的开源方案，比如 Wordpress 和 Halo，使用这些方案，让部署动态博客变得很简单，所以跟静态博客网站相比，使用门槛较低。虽然门槛较低，但是使用者至少要拥有一个个人云服务器，此外还会包含域名解析和配置 SSL 证书、CDN 等内容，整个建站过程涉及的内容还是非常多的。</p><h2 id="1-3：静态博客"><a href="#1-3：静态博客" class="headerlink" title="1.3：静态博客"></a>1.3：静态博客</h2><p>第二种自建博客网站的方式就是静态博客。静态博客框架是在站长自己本地计算机上的，通过运行框架程序生成静态文件 HTML、CSS、JS 等，然后将这些动态生成的静态文件布署到 Web 服务器即可，不需要依赖数据库，当然也不需要管理后台，所有存在于服务器上的博客文章都是静态文件。目前已经有许多优秀的静态博客框架，比如 Hexo 和 Hugo 等。把这种无需依赖数据库系统，也不需要管理后台建立的博客称为静态博客。</p><p>跟动态博客相比，静态博客的优势非常明显：</p><ol><li><strong>速度极快</strong>，因为当用户访问博客时，只用从服务器调取编译好的静态资源即可，无需实时从数据库查询获取博文、图片、评论、访问量等资源，效率极高，打开网站的速度会非常快速！</li><li>作者可以<strong>专心生产博文</strong>，不用管服务器维护等琐事，基本不需要维护，折腾党除外。</li><li><strong>成本低</strong>，市面上有很多开源免费的静态网站托管平台，不用担心高昂的服务器费用。</li><li><strong>很安全</strong>，无需担心数据库注入，跨站攻击等网站安全问题。</li></ol><p>凡事都有两面性，有优点就有缺点：</p><ol><li><strong>硬伤</strong>，无法支持原生评论和访问量统计（可以通过插件来实现），也没办法实现注册登录等功能。</li><li><strong>维护繁琐</strong>，虽然静态博客不用管服务器维护，不用担心高昂的服务器费用，但是没有后台管理，全靠手动编译，如果在原有的基础上改动过多（美化和功能增删）的话，维护起来也是挺费劲的；</li><li><strong>上手难</strong>， 由于无后台管理功能，那么静态博客对新手菜鸟来说真的是难以使用，不懂点前端编程知识的话，根本不用谈使用了，因为你连发布文章都会非常吃力，所以想玩好静态博客，不经历点摸爬滚打是不可能的。不要跟我说简单，因为你的简单只建立在原生无改动的情况下。</li><li><strong>生成速度（编译速度）</strong>，不同的静态博客生成器的速度各不相同，一旦静态资源存在大量图片，速度就会有明显的变化，当然对于坚定静态博客并且喜欢折腾的人来说，这点可以忽略不计。</li></ol><h1 id="第二节：静态网站托管平台"><a href="#第二节：静态网站托管平台" class="headerlink" title="第二节：静态网站托管平台"></a>第二节：静态网站托管平台</h1><h2 id="2-1：静态网站托管"><a href="#2-1：静态网站托管" class="headerlink" title="2.1：静态网站托管"></a>2.1：静态网站托管</h2><p>引用腾讯云上对静态网站托管的一段描述：</p><blockquote><p>静态网站托管是云开发为开发者提供的托管静态网站资源的服务，它提供了一种简单、快速、安全的方式来托管静态网站。静态网站是指网站内容无需动态生成，而是由静态文件（HTML、CSS、JavaScript、图片）组成的网站。静态网站托管可以将这些静态文件存储在云端，并通过 CDN（内容分发网络）加速访问，从而提高网站的访问速度和稳定性。此外，腾讯云静态网站托管还提供了一些方便的工具和功能，如自动部署、自定义域名、HTTPS 支持等，使网站的管理和维护更加简单和高效。</p></blockquote><p><strong>总而言之，静态网站托管是一种服务，这种服务可以将你托管在云端的静态网站资源转变为网站网页！</strong></p><p>我们可以来简单分析一下：因为动态博客的数据是存储于服务器的数据库中的，每次访问的数据都是动态从数据库中查询出来的，所以动态博客需要“计算能力”，至少需要数据库的查询操作吧，所以部署动态博客的话，你至少得购买一台云服务器（当然搭建个人博客所需要的云服务器配置要求不高，毕竟访问量没有那么庞大）。</p><p>相比于动态博客，静态博客就简单很多了，它的数据不是从数据库中获取的，而是直接存在于 HTML 页面中的，所以理论上它不需要“计算能力”，即使是页面上展示出来的一些动态效果，也是 JS 等触发的浏览器行为！因此，我们可以将这些静态代码托管在类似 GitHub 和 Gitee 等平台上，这些平台提供的 Pages 服务（即前面说的静态网站托管服务）可以直接将我们的静态资源转变为网站网页，因此我们可以不用购买昂贵的个人云服务器。也就是说，静态博客不需要服务器大动干戈，只要一个托管平台就解决问题。</p><p>当你想搭建静态博客时，网上搜索，可供使用的平台并不多，以为资源匮乏，实际上只是你未曾了解而已，下面我们来一一例举一些比较常见的静态网站托管平台，并结合我的使用经历和一些大神的心得，来分析一下它们的优劣点，希望对你能有所帮助！</p><h2 id="2-2：Gitee-Pages"><a href="#2-2：Gitee-Pages" class="headerlink" title="2.2：Gitee Pages"></a>2.2：Gitee Pages</h2><p>Gitee Pages 是国内最大的代码托管平台 Gitee 提供的 Pages 服务。</p><p><strong>优点</strong>非常明显，就是稳定性强，速度快（服务器位于上海）。</p><p><strong>缺点</strong>也是很明显的，仓库的最大容量和单个文件大小有限制，对仓库内容非常敏感，需要各种恶心人的实名认证，自定义域名和自动部署都需要收费！</p><p><strong>使用体验</strong>：刚开始我是打算把网站部署在 Gitee Pages 上面的，看重的就是它优秀的访问速度，但是<strong>在搭建的过程中</strong>，各种恶心人的实名认证快给我逼疯了。原本我还认真地按照要求去进行实名认证，直到最后搭建成功以后，在绑定域名的过程中，需要对部署在 Gitee Pages 上面的网站进行备案，而备案的要求是你得有一台云服务器，我瞬间就破防了！先不说我已经在购买域名、开通 Pages 服务这两个步骤中已经实名认证过了，咱就是说你网站备案还要求用户具备云服务器，我就想问一下，假如我有一台云服务器的话，我还会选择用你的 Gitee Pages？此外，实名认证时还要求我上传手持身份证的照片，不知道的还以为我在搞什么网贷呢！其中，网站备案的过程又臭又长，对小白很不友好！这吃相我也是服了（当然这也不能怪 Gitee 本身，毕竟政策要求~~）即使你搭建完成，<strong>在使用的过程中</strong>，每次修改、更新、发布你的文章，推送了代码以后还要用浏览器访问你的 Pages 服务，通过点击更新按钮来重新部署（让你的修改生效），体验感很差（需要注意的是，实际上手动更新这个步骤完全可以免掉，但这是收费功能，真是小气至极）！</p><p><strong>个人建议</strong>：假如部署静态博客网站，我建议你尽量不要选择 Gitee Pages，当然你不怕恶心、不怕个人信息暴露，而且时间多爱折腾的话，你也可以选择它，毕竟跟其他平台相比，它的速度还是数一数二的！（估计也是唯一的优点，跟它的缺点比起来，这个优点可以忽略了）</p><h2 id="2-3：Github-Pages"><a href="#2-3：Github-Pages" class="headerlink" title="2.3：Github Pages"></a>2.3：Github Pages</h2><p>Github Pages 跟 Gitee Pages 是一样的原理，总体上而言它跟 Gitee Pages 的优缺点<font color=red>恰好相反</font>！</p><p><strong>优点</strong>有两点，第一：搭建过程中不需要任何一个实名认证，完全甩 Gitee 十条街；第二，Github Pages 会自动识别仓库代码的变化，并随之更新，不需要每次推送代码后都手动更新（是不是很给力）！</p><p><strong>缺点</strong>也有两点：第一就是访问速度，由于国内的网络限制，Github 在很多地区访问速度很慢，甚至压根无法访问；第二就是原生的 Github Pages 网站无法被百度收录，因为百度的爬虫过于强大，Github 认为它影响了 Github 网站的运行，所以 Github 官方屏蔽了百度的爬虫，使得百度爬虫无法爬取 Github 上的内容！</p><p>但是对于我上述的 Github 的两个缺点，我们都可以借助公共 CDN 技术来解决，比较优秀的就是 Vercel，操作简单而且一劳永逸，一旦配置完成就不用再管了。</p><h2 id="2-4：Cloudflare-Pages"><a href="#2-4：Cloudflare-Pages" class="headerlink" title="2.4：Cloudflare Pages"></a>2.4：Cloudflare Pages</h2><p>Cloudflare Pages 是 Cloudflare 推出的全新网页托管服务。</p><p>优点：不限站点数、请求数和带宽，全球都拥有 CDN 节点，支持自定义域名和自动部署。</p><p>缺点：国内访问速度和稳定性一般，每月构建次数、文件数量和大小都有限制。</p><p>个人观点：放弃 Gitee Pages 和 GitHub Pages 后的一个选择，稳定性不好，经常超时，不过有时候挺快的。但是这种不稳定性是我个人接受不了的，当然也没有尝试过使用它。</p><h2 id="2-5：Coding-Pages"><a href="#2-5：Coding-Pages" class="headerlink" title="2.5：Coding Pages"></a>2.5：Coding Pages</h2><p>国内的平台，但是现在被腾讯收购了，不再免费，使用送的代金券可以适用几个月，所以基本上可以放弃了，再来分析它的优缺点似乎就失去了意义！</p><h2 id="2-6：CloudBase"><a href="#2-6：CloudBase" class="headerlink" title="2.6：CloudBase"></a>2.6：CloudBase</h2><p><a href="https://cloud.tencent.com/document/product/876/40270">CloudBase</a> 是腾讯云推出的静态网站托管服务，也是收费的项目。这里有个故事，它之前的收费方式是有免费套餐和包年包月的套餐，一度成为很多人的选择，但是后来“单方面撕毁计费协议”，所有的套餐都变成了“基础套餐+按量计费”的形式！先不说每个月都要固定支出套餐费用，反正我只要看到“按量计费”这四个字就会放弃，可能是因为我看到过太多博主讲述过他们的凄惨遭遇（个人网站遭受到攻击，被恶意刷流量，导致一觉醒来欠费好几千）！</p><p><strong>个人观点</strong>：使用 CloudBase 这类收费软件，虽然价格不高，但是部署起来比较繁琐，需要配置的东西蛮多的，如果你不差钱的话也可以使用它，它的速度很快（我没试过，但是我觉得最终也逃不过实名认证，况且我对这种无法估算的“按量计费”方式很抵触，所以从一开始就放弃了它）！</p><h2 id="2-7：Vercel"><a href="#2-7：Vercel" class="headerlink" title="2.7：Vercel"></a>2.7：Vercel</h2><p>Vercel 是一个开箱即用的网站托管服务，全球都拥有 CDN 节点，支持自定义域名和自动部署，前身叫 ZEIT。</p><p><strong>优点</strong>：国内访问速度比 Github Pages 和 Cloudflare Pages 要快，支持自定义域名和自动部署。</p><p><strong>缺点</strong>：构建次数和构建时长有限制，每月带宽限制 100G。</p><p><strong>使用体验</strong>：免费静态博客的终极选择，不仅是静态博客，还有基于 Github 的图床等，也可以使用 Vercel 来解决访问速度的痛点！</p><h2 id="2-8：Netlify"><a href="#2-8：Netlify" class="headerlink" title="2.8：Netlify"></a>2.8：Netlify</h2><p><a href="https://netlify.com/">Netlify</a> 是国外平台，免费，国内访问速度还可以，个人感觉仅次于 Vercel，但和 Vercel 一样，带宽限制为每月 100G，可作为 Vercel 的替代方案！</p><p>~~</p><p>~~</p><p>~~</p>]]></content>
      
      
      <categories>
          
          <category> 技术白话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> Vercel </tag>
            
            <tag> Gitee </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名背后那些事儿</title>
      <link href="/post/10041.html"/>
      <url>/post/10041.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：概念理解"><a href="#第一节：概念理解" class="headerlink" title="第一节：概念理解"></a>第一节：概念理解</h1><h2 id="1-1：IP地址是什么"><a href="#1-1：IP地址是什么" class="headerlink" title="1.1：IP地址是什么"></a>1.1：IP地址是什么</h2><blockquote><p>IP 地址（Internet Protocol Address）是指互联网协议地址，又译为网际协议地址。</p></blockquote><p>IP 地址是 IP 协议提供的一种统一的地址格式，它为互联网上的每一个网络和每一台主机分配一个逻辑地址，以此来屏蔽物理地址的差异。</p><p>位于网络上的每个服务器都有一个唯一的IP地址，例如<code>61.135.169.125</code>就是百度的官网地址之一，如果每次访问百度都输入 IP 的话，估计到今天互联网还没有走出鸿蒙阶段！</p><h2 id="1-2：域名是什么"><a href="#1-2：域名是什么" class="headerlink" title="1.2：域名是什么"></a>1.2：域名是什么</h2><p><font color=red>域名就是 IP 地址的别名！</font>在网络发展历史上，最开始确实就是直接使用 IP 地址来访问远程主机的。早期联网的每台计算机都是采用主机文件（即我们俗称的 hosts 文件）来进行地址配置和解析的，也就是将主机的域名和IP的对应关系配置在主机文件中。这样，在地址栏输入更容易记忆的域名，就可以解析成 IP 地址，就可以实现连接访问。</p><p>域名比 IP 地址更容易记忆，本质上只是为数字化的互联网资源提供了易于记忆的别名，就像在北京提起“故宫博物院”就都知道指的是“东城区景山前街4号”的那个大院子一样。如果把 IP 地址看成电话号码，那域名系统就是通讯录。我们在通讯录里保存了朋友和家人的信息，每次通过名字找到某人打电话的时候，通讯录就会查出与之关联的电话号码再拨号过去。我们可能记不下多少完整的电话号码，但是联系人的名字却是一定记得的。</p><h2 id="1-3：DNS是什么"><a href="#1-3：DNS是什么" class="headerlink" title="1.3：DNS是什么"></a>1.3：DNS是什么</h2><blockquote><p>域名系统（DNS）就是用来将域名解析成 IP 地址的网络服务！</p></blockquote><p>后来联网机器越来越多，主机文件的更新和同步就成了很大的问题。于是，1983 年保罗·莫卡派乔斯发明了域名解析服务和域名系统，在 1985 年 1 月 1 日，世界上第一个域名 <a href="http://nordu.net/">nordu.net</a> 才被注册成功。单凭这一个名字我们并不能访问到正确的地址，只有能将域名解析成实际的网络地址，网络访问才能成功。这种解析工作由专门的「域名系统」（Domain Name System，简称 DNS）完成，DNS 也是互联网的核心基础服务之一。</p><h1 id="第二节：域名解析"><a href="#第二节：域名解析" class="headerlink" title="第二节：域名解析"></a>第二节：域名解析</h1><h2 id="2-1：域名层次结构"><a href="#2-1：域名层次结构" class="headerlink" title="2.1：域名层次结构"></a>2.1：域名层次结构</h2><p>我们经常听到有人说「顶级域名」、「一级域名」、「二级域名」等概念，域名级别究竟是怎么划分的呢？</p><ul><li><p><font color=red><strong>根域名</strong></font></p><p>所有域名的根域名都是一样的，就是<code>.root</code>！以百度为例，通过一些域名解析工具，我们可以看到百度的官方域名显示为<code>www.baidu.com.</code>，细心的人会注意到最后有一个点，这不是 bug，而是所有域名的尾部都有根域名，所以百度真正的域名是<code>www.baidu.com.root</code>，简写为<code>www.baidu.com</code>，又因为根域名对于所有的域名都一样，所以平时是省略的，最终就变成了我们常见的样子<code>www.baidu.com</code>。</p></li><li><p><font color=red><strong>一级域名（TLD），也叫顶级域名</strong></font></p><p>根域名的下一级叫做顶级域名，也叫做一级域名，常见的如 <code>.com</code>、<code> / .net</code>、<code>/ .org</code>、<code>/ .cn</code> 等等。</p></li><li><p><font color=red><strong>二级域名（SLD），也叫主域名</strong></font></p><p>一级域名的下一级就是二级域名，比如<code>baidu.com</code>。</p></li><li><p><font color=red><strong>次级域名，也叫主机名</strong></font></p><p>二级域名的下一级域名就是三级域名，比如<code>www.baidu.com</code>。</p></li></ul><p>一般来说我们购买一个域名就是购买一个二级域名（SLD）的管理权（如 leancloud.cn），有了这个管理权我们就可以随意设置三级、四级域名了。</p><h2 id="2-2：域名解析过程"><a href="#2-2：域名解析过程" class="headerlink" title="2.2：域名解析过程"></a>2.2：域名解析过程</h2><p><font color=red><strong>DNS系统也是一个树状结构</strong></font>，<font color=red><strong>不同级别的域名由不同的域名服务器来解析</strong></font>，<font color=red><strong>整个过程是一个层级式的</strong></font>。</p><ul><li>层级式域名解析体系的第一层就是<font color=red><strong>根域名服务器</strong></font>，全世界IPv4根域名服务器只有 13 台(名字分别为 A 至 M)，其中1 个为主根服务器在美国，其余 12 个均为辅根服务器，它们负责管理世界各国的域名信息。一个域名必须首先经过根数据库的解析后，才能转到顶级域名服务器进行解析；</li><li>根域名服务器下面是<font color=red><strong>顶级域名服务器</strong></font>，即相关国家域名管理机构的数据库，比如我们中国的互联网络信息中心(CNNIC)；</li><li>然后是再下一级的权威域名服务器和 ISP 的缓存服务器；</li></ul><p>举个例子，来模拟一下这个流程！假设北京市设立了一个专门的“道路咨询局”，里面设置了局长、部长、处长、科员好几个级别的公务员，不同的部门、科室、人员负责解答不同区域的道路问题。这里的人都有一个共同特点，信奉“好记性不如烂笔头”的哲理，喜欢将自己了解到的信息记录到笔记本上。但是有一点遗憾的是，他们写字用的墨水只有一种，叫“魔术墨水”，初写字迹浓厚，之后会慢慢变淡，1 小时之后则会完全消失。道路咨询局门口还有一个门卫大爷，所有的人要问路都需要通过他来传达和回复，市民并不能进入办公楼。</p><p>如果市民 A 先生来找门卫大爷询问“北海公园”的地址，门卫大爷会先看一下自己的笔记本，找找看在此之前的一个小时内有没有人问过北海公园。如果没有，他就会拨打内线去找局长求助。局长说北海是西城区，你去问负责西城区道路信息的赵部长吧。门卫大爷又去问赵部长，赵部长查了一下，说这个地址你去问负责核心区的钱处长吧。门卫大爷又给钱处长打过去电话，钱处长说这个地址我也不掌握啊，你去问一下负责景山片区的科员小孙吧。门卫大爷从小孙那里终于知道了北海公园地址，他赶紧记到自己的小本本上，然后把结果告诉了市民 A 先生。接下来一小时内，如果还有市民 B 先生再来问北海公园的话，门卫大爷就直接用笔记本上记载的结果回复了。当然，如果市民 C 女士过来问别的地址的话，门卫大爷就要把处理 A 先生问询的流程再走一遍了。</p><h2 id="2-3：分级查询实例"><a href="#2-3：分级查询实例" class="headerlink" title="2.3：分级查询实例"></a>2.3：分级查询实例</h2><p>举个例子来说明域名解析的分级查询。比如，现在我在谷歌浏览器的地址栏输入一个网址<code>https://news.qq.com</code>，那么浏览器会从接收的URL中抽取出域名字段(<code>news.qq.com</code>)，然后将它传给DNS客户端(操作系统提供的)来解析。</p><p>在Linux系统中，<code>/etc/resolv.conf</code>文件中，制定了本地DNS服务器的地址，Windows系统会有所不同：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> cat /etc/resolv.conf</span><br><span class="line">nameserver 202.106.0.20</span><br><span class="line">nameserver 202.106.196.115</span><br></pre></td></tr></table></figure><p>然后我们用dig工具查看一下new.qq.com的解析结果(其中中文部分是解释说明)：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> dig news.qq.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; news.qq.com</span><br><span class="line">这是 dig 程序的版本号与要查询的域名</span><br><span class="line"></span><br><span class="line">;; global options: +cmd</span><br><span class="line">;; Got answer:</span><br><span class="line">以下是要获取的内容。</span><br><span class="line"></span><br><span class="line">;; -&gt;&gt;HEADER&lt;&lt;- opcode: QUERY, status: NOERROR, id: 47559</span><br><span class="line">;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 0</span><br><span class="line">这个是返回应答的头部信息：</span><br><span class="line">1. opcode：操作码，QUERY 代表查询操作；</span><br><span class="line">2. status: 状态，NOERROR 代表没有错误;</span><br><span class="line">3. id：编号，在 DNS 协议中通过编号匹配返回和查询；</span><br><span class="line">4. flags: 标志，含义如下:</span><br><span class="line">   - qr：query，查询标志，代表是查询操作</span><br><span class="line">   - rd：recursion desired，代表希望进行递归查询操作;</span><br><span class="line">   - ra：recursive available，代表查询的服务器支持递归查询操作;</span><br><span class="line">5. QUERY 查询数，与下面 QUESTION SECTION 的记录数一一对应；</span><br><span class="line">6. ANSWER 结果数，与下面的 ANSWER SECTION 的记录数一一对应；</span><br><span class="line">7. AUTHORITY 权威回复数，如果查询结果由管理域名的域名服务器而不是缓存服务器提供的，则称为权威回复。</span><br><span class="line">             0 表示所有结果都不是权威回复；</span><br><span class="line">8. ADDITIONAL 额外记录数；</span><br><span class="line"></span><br><span class="line">;; QUESTION SECTION:</span><br><span class="line">;news.qq.com.INA</span><br><span class="line">查询部分,从左到右部分意义如下:</span><br><span class="line">1、要查询的域名；</span><br><span class="line">2、要查询信息的类别，IN 代表类别为 IP 协议，即 Internet。</span><br><span class="line">3、查询的记录类型，A 记录(Address)代表要查询 IPv4 地址。</span><br><span class="line"></span><br><span class="line">;; ANSWER SECTION:</span><br><span class="line">news.qq.com.136INCNAMEhttps.qq.com.</span><br><span class="line">https.qq.com.476INA125.39.52.26</span><br><span class="line">回应部分，从左到右各部分意义：</span><br><span class="line">1、对应的域名</span><br><span class="line">2、TTL，time to live，缓存时间，单位秒，代表缓存域名服务器可以在缓存中保存的期限。</span><br><span class="line">3、查询信息的类别</span><br><span class="line">4、查询的记录类型，CNAME 表示别名记录，A 记录(Address)代表 IPv4 地址。</span><br><span class="line">5、域名对应的 ip 地址。</span><br><span class="line"></span><br><span class="line">;; Query time: 56 msec</span><br><span class="line">;; SERVER: 202.106.0.20<span class="params">#5</span>3(202.106.0.20)</span><br><span class="line">查询使用的服务器地址和端口,其实就是本地 DNS 域名服务器</span><br><span class="line">;; WHEN: Thu Jul 11 15:59:37 CST 2019</span><br><span class="line">;; MSG SIZE  rcvd: 65</span><br><span class="line">查询的时间与回应的大小，收到 65 字节的应答数据。</span><br></pre></td></tr></table></figure><p>从这个结果可以看到，我们得到的结果不是权威回复，只是本地DNS服务器从缓存中给出的答案。</p><p>接下来我们在dig命令中新增一个参数<code>+trace</code>，看看完整的分级查询过程：</p><figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">$</span> dig +trace news.qq.com</span><br><span class="line"></span><br><span class="line">; &lt;&lt;&gt;&gt; DiG 9.10.6 &lt;&lt;&gt;&gt; +trace news.qq.com</span><br><span class="line">;; global options: +cmd</span><br><span class="line">.432944INNSg.root-servers.net.</span><br><span class="line">.432944INNSk.root-servers.net.</span><br><span class="line">.432944INNSb.root-servers.net.</span><br><span class="line">.432944INNSh.root-servers.net.</span><br><span class="line">.432944INNSi.root-servers.net.</span><br><span class="line">.432944INNSf.root-servers.net.</span><br><span class="line">.432944INNSd.root-servers.net.</span><br><span class="line">.432944INNSe.root-servers.net.</span><br><span class="line">.432944INNSj.root-servers.net.</span><br><span class="line">.432944INNSl.root-servers.net.</span><br><span class="line">.432944INNSc.root-servers.net.</span><br><span class="line">.432944INNSm.root-servers.net.</span><br><span class="line">.432944INNSa.root-servers.net.</span><br><span class="line">;; Received 228 bytes from 202.106.0.20<span class="params">#5</span>3(202.106.0.20) in 45 ms</span><br><span class="line">这些就是神秘的根域名服务器，由本地 DNS 服务器返回了所有根域名服务器地址。</span><br><span class="line"></span><br><span class="line">com.172800INNSg.gtld-servers.net.</span><br><span class="line">com.172800INNSa.gtld-servers.net.</span><br><span class="line">com.172800INNSb.gtld-servers.net.</span><br><span class="line">com.172800INNSm.gtld-servers.net.</span><br><span class="line">com.172800INNSd.gtld-servers.net.</span><br><span class="line">com.172800INNSc.gtld-servers.net.</span><br><span class="line">com.172800INNSj.gtld-servers.net.</span><br><span class="line">com.172800INNSh.gtld-servers.net.</span><br><span class="line">com.172800INNSf.gtld-servers.net.</span><br><span class="line">com.172800INNSl.gtld-servers.net.</span><br><span class="line">com.172800INNSe.gtld-servers.net.</span><br><span class="line">com.172800INNSk.gtld-servers.net.</span><br><span class="line">com.172800INNSi.gtld-servers.net.</span><br><span class="line">;; Received 1171 bytes from 192.36.148.17<span class="params">#5</span>3(i.root-servers.net) in 57 ms</span><br><span class="line">这里显示的是 .com 域名的 13 条 NS 记录，本地 DNS 服务器向这些顶级域名服务器发出查询请求，</span><br><span class="line">询问 qq.com 的 NS 记录。</span><br><span class="line"></span><br><span class="line">qq.com.172800INNSns1.qq.com.</span><br><span class="line">qq.com.172800INNSns2.qq.com.</span><br><span class="line">qq.com.172800INNSns3.qq.com.</span><br><span class="line">qq.com.172800INNSns4.qq.com.</span><br><span class="line">;; Received 805 bytes from 192.48.79.30<span class="params">#5</span>3(j.gtld-servers.net) in 331 ms</span><br><span class="line">这里显示的是 qq.com 的 4 条 NS 记录，由 j.gtld-servers.net 这台服务器最先返回。</span><br><span class="line">然后本地 DNS 服务器向这四台服务器查询下一级域名 news.qq.com 的 NS 记录。</span><br><span class="line"></span><br><span class="line">news.qq.com.86400INNSns-cnc1.qq.com.</span><br><span class="line">news.qq.com.86400INNSns-cnc2.qq.com.</span><br><span class="line">;; Received 180 bytes from 58.144.154.100<span class="params">#5</span>3(ns4.qq.com) in 37 ms</span><br><span class="line">这里显示的是 news.qq.com 的 NS 记录，它们是由上面的 ns4.qq.com 域名服务器返回的。</span><br><span class="line">然后本地 DNS 服务器向这两台机器查询 news.qq.com 的主机名。</span><br><span class="line"></span><br><span class="line">news.qq.com.600INCNAMEhttps.qq.com.</span><br><span class="line">https.qq.com.600INA125.39.52.26</span><br><span class="line">;; Received 76 bytes from 223.167.83.104<span class="params">#5</span>3(ns-cnc2.qq.com) in 29 ms</span><br><span class="line">这是上面的 ns-cnc2.qq.com 返回的最终查询结果：</span><br><span class="line">news.qq.com 是 https.qq.com 的别名，而 https.qq.com 的 A 记录地址是 125.39.52.26</span><br></pre></td></tr></table></figure><p><font color=red><strong>总结</strong></font>：</p><p>实际的流程里面，本地 DNS 服务器相当于门卫大爷，根域名服务器相当于局长同志，其余以此类推。客户端与本地 DNS 服务器之间的查询叫递归查询，本地 DNS 服务器与其他域名服务器之间的查询就叫迭代查询。</p><h2 id="2-4：域名记录类型"><a href="#2-4：域名记录类型" class="headerlink" title="2.4：域名记录类型"></a>2.4：域名记录类型</h2><p>域名服务器之所以能知道域名与 IP 地址的映射关系，是因为我们在域名服务商那里提交了域名记录。我们购买了一个域名后，需要在域名服务商那里设置域名解析的记录，域名服务商把这些记录推送到权威域名服务器，这样我们的域名才能正式生效。在添加域名记录时，会遇到<code>A 记录</code>、<code>CNAME记录</code> 等不同类型，这些类型是什么意思，它们之间又有什么关系和区别呢？</p><ul><li><p><font color=red><strong>A 记录</strong></font>：</p><p>A记录用来直接指定主机名(或域名)对应的IP地址。常见有如下几种：</p><ul><li><font color=blue>www</font>：解析后的域名为 <code>www.yourdomain.com</code>，一般用于网站地址；</li><li><font color=blue>@</font>：直接解析主域名；</li><li><font color=blue>*</font>：泛解析，指将 <code>.yourdomain.com</code> 解析到同一 IP；</li></ul></li><li><p><font color=red><strong>CNAME 记录</strong></font></p><p>CNAME的全称是<strong>Canonical Name</strong>，通常称别名记录。如果需要将域名指向另一个域名，再由另一个域名提供IP地址，就需要添加CNAME记录。</p></li><li><p>MX 记录</p><p>邮件交换记录，用于将以该域名为结尾的电子邮件指向对应的邮件服务器以进行处理。</p></li><li><p>NS 记录</p><p>域名服务器记录，如果需要把子域名交给其他 DNS 服务器解析，就需要添加 NS 记录。</p></li><li><p>AAAA 记录</p><p>用来指定主机名（或域名）对应的 IPv6 地址，不常用。</p></li><li><p>TXT 记录</p><p>可以填写任何东西，长度限制 255。绝大多数的 TXT 记录是用来做 SPF 记录（反垃圾邮件），MX 记录的作用是给寄信者指明某个域名的邮件服务器有哪些。SPF 的作用跟 MX 相反，它向收信者表明，哪些邮件服务器是经过某个域名认可会发送邮件的。</p></li><li><p>显性 URL</p><p>从一个地址 301 重定向（也叫「永久性转移」）到另一个地址的时候，就需要添加显性 URL 记录。</p></li><li><p>隐性 URL</p><p>从一个地址 302 跳转（也叫「临时跳转」）到另一个地址，需要添加隐性 URL 记录。它类似于显性 URL，区别在于隐性 URL 不会改变地址栏中的域名。</p></li></ul><p>在填写各种记录的时候，我们还会碰到一个特殊的设置项——<code>TTL</code>，生存时间（Time To Live）。</p><p><code>TTL</code>表示解析记录在 DNS 服务器中的缓存时间，时间长度单位是秒，一般为3600秒。比如：我们在访问<code>news.qq.com</code>时，如果在 DNS 服务器的缓存中没有该记录，就会向某个 NS 服务器发出请求，获得该记录后，该记录会在 DNS 服务器上保存<code>TTL</code>的时间长度，在<code>TTL</code>有效期内访问<code>news.qq.com</code>，DNS 服务器会直接缓存中返回刚才的记录。</p><h2 id="2-5：DNS智能解析"><a href="#2-5：DNS智能解析" class="headerlink" title="2.5：DNS智能解析"></a>2.5：DNS智能解析</h2><p>DNS主要的工作就是完成域名到 IP 的映射，但是也不是简单到查查字典就可以搞定的程度。在设置 DNS 解析的时候，我们还有一些额外的需求，例如：将一个域名解析到多个 IP！</p><p>例如我们一个网站有多台前端机，希望用户访问的时候，可以随机分散到这些机器上，以增加网站承载能力。有一种解决的办法就是对同一个域名设置多条 A 记录，分别指定到不同的 IP 上。</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 技术白话 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 域名解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github + Vercel 搭建免费的个人图床</title>
      <link href="/post/10023.html"/>
      <url>/post/10023.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><h2 id="1-1：各种图床"><a href="#1-1：各种图床" class="headerlink" title="1.1：各种图床"></a>1.1：各种图床</h2><p>经常使用 Markdown 进行文章创作的人，肯定对“图床”这个概念不陌生，拥有个人图床则更是一个刚需！现在市面上的图床产品非常多，有免费的也有收费的，也有一些是“限量免费”的。</p><p>其中收费的有腾讯云和阿里云等云服务商提供的对象存储服务，基本是按流量收费的，费用很低，如果你不想折腾，又不差这点钱，我还是强烈建议使用大厂的对象存储！它们能兼顾稳定性和存取速度！（<font color=red>友情提示</font>：假如你使用这种按流量收费的图床服务并将其中的图片放到自己的网站上的话，一定要处理好安全配置，并配合 CDN 来使用，否则一旦你的网站被攻击恶意刷流量的话，那么可能一觉起来你就欠费上千块了！）</p><p>以七牛云为代表的图床也是不错的，但免费的图床一般都会有空间限制，比如你只有500MB的免费空间，当你图片超过这个免费额度后，就得购买新的空间了。此外，免费的图床还有一个致命的缺点，就是稳定性差！所谓稳定性差，就是有可能会倒闭或者跑路！试想以下，你辛辛苦苦攒的图片，因为图床供应商倒闭了或者跑路了，你的所有图片都会化为泡影！</p><p>免费的和收费的图床各有优劣，我就不再赘述了，我这篇博文主要是用来记录如何使用 Github 来搭建一个免费的图床！</p><h2 id="1-2：Github"><a href="#1-2：Github" class="headerlink" title="1.2：Github"></a>1.2：Github</h2><p>对于免费的图床，我选择的是 Github，使用 Github 搭建图床具备以下优势：</p><ul><li>很稳定，不会跑路，作为全球最大的代码托管平台，这一点毋庸置疑；</li><li>使用自己的仓库来存储图片，图片可以增量快速更新，跨设备管理；</li><li>因为使用 Git 进行上传和下载，可以进行版本管理和查看之前的版本；</li></ul><p>当然，Github 图床也有一些显著的缺点：</p><ul><li>每个仓库限制 1 G，超过这个容量就要新建一个仓库；</li><li>在国内由于网络限制，访问速度很不理想，甚至不能访问，但配合免费公共的 CDN，读取速度还是相当不错的；</li><li>使用 Github 做图床，你就担上了滥用开源的罪名！（<del>当我没说，哈哈</del>）</li></ul><h2 id="1-3：我的选择"><a href="#1-3：我的选择" class="headerlink" title="1.3：我的选择"></a>1.3：我的选择</h2><p>总体而言，使用 Github 做图床还是很可取的，尤其是存放那些经常被访问的图片（毕竟是免费的啊）。比如，在我的博客网站中有很多图片，所有的图片主要分为两类：第一类是网站的背景图等公共图片；第二类是文章中的插图等非公共资源。前者被访问的频率显然要比后者更高，这也就意味着在我的博客网站中公共图片会产生更多的流量。所以，我采取如下策略：首先，将经常被访问的公共图片放在 Github 上，这样就不用为这部分流量付钱了；其次，将非公共图片放到腾讯云的对象存储 COS 中，因为非公共图片被访问的频率低，并且图片较多，可以集成 PicGo 来实现一键上传，重要的是使用对象存储可以显著提供文件的加载速度，省去了配置 CDN 的麻烦。</p><p><font color=red>特别提示</font>：无论你将自己的图片托管在哪个平台上，都应该做好备份，因为只要是第三方的服务，都有可能因为各种各样的原因而失去，谁也不能保证万无一失！</p><h1 id="第二节：具体配置"><a href="#第二节：具体配置" class="headerlink" title="第二节：具体配置"></a>第二节：具体配置</h1><h2 id="2-1：创建仓库"><a href="#2-1：创建仓库" class="headerlink" title="2.1：创建仓库"></a>2.1：创建仓库</h2><p>登录 Github 官网，假如你还没有账号则需要注册一个，然后创建一个仓库，比如我创建的图床仓库：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021205430860.png"></p><p>点击最后的<code>Create repository</code>后，就创建了一个仓库：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021205644236.png"></p><h2 id="2-2：克隆仓库"><a href="#2-2：克隆仓库" class="headerlink" title="2.2：克隆仓库"></a>2.2：克隆仓库</h2><p>在你计算机本地找一个目录，将 Github 上创建的图床仓库克隆下来，比如我将其放在我桌面的<code>repository</code>文件中：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021205919665.png"></p><p>然后本地仓库就生成了：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021211146191.png"></p><h2 id="2-4：上传图片"><a href="#2-4：上传图片" class="headerlink" title="2.4：上传图片"></a>2.4：上传图片</h2><p>此时就可以使用 Git 往这个仓库中推送图片了，但为了方便图片的管理，一般我们会在仓库中创建子目录。比如我先创建了一个名为<code>avatars</code>的文件夹，然后在其中放入了一张名为<code>boy.png</code>的图片（顺便创建<code>.gitignore</code>文件）：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021211333758.png"></p><p><font color=red><strong>友情注意</strong></font>：此时就可以将本地仓库推送到 Github 仓库了！但是第一次提交代码的时候，需要验证用户名和密码，这里用户名输入 Github 的用户名，<font color=red>但密码则不是你的登录密码，而是你仓库的口令——token</font>！因为从 2021 年 8 月 13 日开始，Github 就不再接受密码验证了，转而接受 token！所以为了建立你的计算机和 Github 仓库的通信，你首先需要创建一个口令（假如你不知道如何创建口令，可以参考我的这篇博文<a href="https://www.fattymonkey.com/post/10021.html">《Github使用口令替代密码来进行上传验证》</a>）！</p><p>上传成功以后，可以在 Github 仓库看到上传的资源：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021211801431.png"></p><h2 id="2-5：访问图片"><a href="#2-5：访问图片" class="headerlink" title="2.5：访问图片"></a>2.5：访问图片</h2><p>将图片上传到 Github 仓库后，我们怎么样访问仓库中的图片呢？使用如下两种路径：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/用户名/仓库名/blob/分支名/图片在仓库中的绝对路径?raw=true</span><br><span class="line">https://github.com/用户名/仓库名/raw/分支名/图片在仓库中的绝对路径</span><br></pre></td></tr></table></figure><p>比如访问仓库中位于<code>avatars</code>文件夹中的名为<code>boy.png</code>的图片，那么它的路径就是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fattymonkey/blog-source/blob/main/avatars/boy.png?raw=true</span><br><span class="line">https://github.com/fattymonkey/blog-source/raw/main/avatars/boy.png</span><br></pre></td></tr></table></figure><h1 id="第三节：配置加速"><a href="#第三节：配置加速" class="headerlink" title="第三节：配置加速"></a>第三节：配置加速</h1><p>将图片上传到 Github 仓库以后，通过使用 Github 给我们的图片路径，就可以访问图片了。但此时还存在一个很严重的问题，就是网络问题。Github 是国外的网站，由于我们国内的网络限制，访问速度很慢，大多数时候甚至根本访问不了！为了解决这个问题，我们就必须为 Github 使用 CDN 加速！目前推荐的 CDN 加速有以下三种。</p><h2 id="3-1：Statically"><a href="#3-1：Statically" class="headerlink" title="3.1：Statically"></a>3.1：Statically</h2><p>很多人都知道 Jsdelivr，开发者们经常会用它来加速 CSS 或 JS 之类的静态资源，当然也会有部分哥们用它来加速图像服务（但在这里建议适量使用，滥用不是一个好的思想）。</p><p>Statically 也是一款为开发者免费提供的 CDN 加速服务，它与 Jsdelivr 一样有着深厚的资源支持，同时其支持的内容更加丰富一些。并且它目前是免费的，速度也是相当不错（且用且珍惜吧）。</p><h3 id="3-1-1：配置"><a href="#3-1-1：配置" class="headerlink" title="3.1.1：配置"></a>3.1.1：配置</h3><p>Statically 压根就不用配置，只需要在访问图片时，修改访问图片的 URL 路径即可。</p><h3 id="3-1-2：使用"><a href="#3-1-2：使用" class="headerlink" title="3.1.2：使用"></a>3.1.2：使用</h3><p>比如 Github 提供给我们的图片链接是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/用户名/仓库名/blob/分支名/图片在仓库中的绝对路径?raw=true</span><br><span class="line">https://github.com/用户名/仓库名/raw/分支名/图片在仓库中的绝对路径</span><br></pre></td></tr></table></figure><p>我们只需要将其修改为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/gh/用户名/仓库名@分支名/图片在仓库中的绝对路径</span><br></pre></td></tr></table></figure><p>这样就可以访问了，简单且高效！</p><h2 id="3-2：Vercel"><a href="#3-2：Vercel" class="headerlink" title="3.2：Vercel"></a>3.2：Vercel</h2><p>Vercel 现在非常火爆，Vercel 类似 Github Pages，但远比 Github Pages 强大，速度也快得多，而且将 Github 授权给 Vercel 后，可以得到最优雅的发布体验只需要将代码推送，项目就自动更新部署了！Vercel 还支持 serverless 接口，这就意味着它不仅可以部署静态网站，还可以部署动态网站，而这些功能通通都是免费的，简直就是白嫖党的福利！Vercel 还支持 https ，不用自己去 FreeSSL 申请证书，更是省去了一大堆的证书配置，简直就是懒人的福利！</p><p>使用 Vercel 来部署我们的图床仓库，能极大的提升访问速度，因为它提供了全局的 CDN 加速！但是现在 Vercel 的域被墙了，需要绑定一个自己的域名才能在国内访问，并且有每个月 100 G 的流量限制（问题不大，我觉得完全够用）。</p><h3 id="3-2-1：注册账号"><a href="#3-2-1：注册账号" class="headerlink" title="3.2.1：注册账号"></a>3.2.1：注册账号</h3><p>访问 Vercel <a href="https://vercel.com/">官网</a>，建议选择使用 Github 账号来注册。<font color=red><strong>注意</strong></font>：大多数情况下我们的 Github 账号是用国内的邮箱注册的，但是 Vercel 在验证 Github 账号的时候会校验它的主邮箱，假如你 Github 的主邮箱是国内邮箱的话，就会注册失败！一旦你注册失败，就会出现下面的情况：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212119857.png"></p><p>建议<font color=red>在注册 Vercel 之前就把你 Github 的主邮箱修改为国外的邮箱</font>，如果你已经使用了国内的邮箱注册了 Github，那么：</p><ol><li><p>注册一个谷歌邮箱，国内访问<code>Gmail</code>的方案：</p><ul><li><p>直接使用 QQ 邮箱手机版，它提供 <code>Gmail</code> 的访问路线，可以直接注册并使用；</p></li><li><p>使用 <code>Ghelper</code> 等浏览器插件访问。详情可以参考这篇文章：<a href="https://github.com/Zfour/python_github_calendar_api/blob/master/posts/8c8df126">玩转 Microsoft-Edge</a></p></li></ul></li><li><p>将注册的谷歌邮箱设置为 Github 的主邮箱</p><ul><li><p><code>头像</code> &gt; <code>Settings</code> &gt; <code>Emails</code>，然后添加注册的谷歌邮箱，然后验证添加的邮箱；</p></li><li><p>最后在<code>Primary email address</code>下方选择前面添加的谷歌邮箱；</p></li></ul></li><li><p>访问Vercel官网，使用谷歌邮箱进行注册，注册的时候需要验证手机号，国内手机号也可以，完成注册</p></li></ol><h3 id="3-2-2：部署仓库"><a href="#3-2-2：部署仓库" class="headerlink" title="3.2.2：部署仓库"></a>3.2.2：部署仓库</h3><p>进入 Vercel 控制面板，点击页面的“Create a New Project”，在“Import Git Repository”处选择前面创建的仓库：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212501911.png"></p><p>然后点击对应仓库的“Import”按钮，然后直接点击“Deploy”按钮来部署：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212641548.png"></p><p>稍等片刻，就能看到部署项目成功的提示（Congratulations）：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212815121.png"></p><p><font color=red>友情提示</font>：此时可见左边的项目页面报错 404，这是因为我们仓库的根目录下没有名为<code>index.html</code>的文件，我们可以在仓库根目录下创建这个文件，就能消除这个警告！比如我在仓库根目录下创建了这个文件，并编辑它的内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的博客资源<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color:red;text-align: center;&quot;</span>&gt;</span>博客资源仓库部署成功<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传到仓库后，点击右上角的“Continue to Dashboard”，进入项目控制台，可见效果：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021213244947.png"></p><h3 id="3-2-3：绑定域名"><a href="#3-2-3：绑定域名" class="headerlink" title="3.2.3：绑定域名"></a>3.2.3：绑定域名</h3><p>Vercel 给我们分配了一个域名，也就是上图中的<code>blog-source-two.vercel.app</code>，原本我们可以使用这个域名来访问我们的仓库，但由于现<code>.app</code>这个域被墙了，所以我们需要配置一个自己的域名才能访问！</p><p>点击右上方的“Domains”，添加一个自己的域名：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021213457561.png"></p><p>然后点击“Add”，此时发现添加的域名是无效的：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021213951367.png"></p><h3 id="3-2-4：配置解析"><a href="#3-2-4：配置解析" class="headerlink" title="3.2.4：配置解析"></a>3.2.4：配置解析</h3><p>然后去我们购买域名的域名解析处，配置上图中提示给我们的两条解析记录，比如我的情况是：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021215659785.png"></p><p>配置完等待 DNS 生效，然后 Vercel 还会自动配置 SSL 安装证书，最终：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021215815108.png"></p><h3 id="3-2-5：具体使用"><a href="#3-2-5：具体使用" class="headerlink" title="3.2.5：具体使用"></a>3.2.5：具体使用</h3><p>现在，我们就可以使用自定义的域名来访问图片了！访问的 URL 是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义域名/图片的仓库路径</span><br></pre></td></tr></table></figure><p>比如图片在仓库中的路径是<code>/avatars/boy.png</code>，那么就可以在浏览器地址栏中使用下面这两个路径来访问图片：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">czblogs.cn/avatars/boy.png</span><br><span class="line">www.czblogs.cn/avatars/boy.png</span><br></pre></td></tr></table></figure><p><font color=red>注意</font>：在 Markdown 中要加上<code>https://</code>，因为 Markdown 不能像浏览器那样自动为 URL 添加这个前缀！</p><h2 id="3-3：CloudFlare"><a href="#3-3：CloudFlare" class="headerlink" title="3.3：CloudFlare"></a>3.3：CloudFlare</h2><p>cloudflare 的访问速度比 Vercel 的速度差一点，Vercel 是我目前使用的方式，暂时先不更新 cloudflare 的配置和使用！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> CDN </tag>
            
            <tag> Vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这篇文章或许能让你彻底了解Markdown</title>
      <link href="/post/10022.html"/>
      <url>/post/10022.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：基本概述"><a href="#第一节：基本概述" class="headerlink" title="第一节：基本概述"></a>第一节：基本概述</h1><h2 id="1-1：它是什么"><a href="#1-1：它是什么" class="headerlink" title="1.1：它是什么"></a>1.1：它是什么</h2><blockquote><p>Markdown 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素，允许人们使用易读易写的纯文本格式编写文档。Markdown 由 John Gruber 于 2004 年创建，如今已成为世界上最受欢迎的标记语言之一。</p></blockquote><p>最开始的时候，人们使用记事本来编辑文档，但是后来发现纯文本文档真的太单调了！然后，Word 闪亮登场，从此 Word 就成为了编辑文本文档的主要工具，在 Word 中人们可以对任意的文字进行排版美化，比如设置各级标题以及文字的大小和颜色。Word 丰富多彩的文本样式，让它成为了主流的文本信息传播手段。但随着网络的发展，Word 文件过于笨重的缺点就暴露出来了，此时又诞生了 HTML，它可以使用轻量级的标记来实现文本文档的渲染，但是它的渲染功能依赖于解释环境（浏览器就是最常见的解释器），在信息传播的过程中没有那么随心所欲。</p><p>对于平时需要进行大量码字的人而言，显然笨重的 Word 和依赖浏览器的 HTML 都不符合他们的诉求。因此，诞生了 Markdown，它跟 HTML 语法一样，也是使用各种标记来实现文本样式的渲染，但是跟 HTML 相比，它更加轻量级，更加简单！在电脑系统中，Markdown 文本文件就是以<code>md</code>或<code>MD</code>为扩展名的文件！</p><p><font color=red>假如你对 HTML 有基本的了解，那么此时你就可以将 Markdown 理解为简化版的 HTML ！并且在 Markdown 文本中可以直接使用 HTML 元素而无需转译！</font></p><h2 id="1-2：使用场景"><a href="#1-2：使用场景" class="headerlink" title="1.2：使用场景"></a>1.2：使用场景</h2><p>由于 Markdown 轻量化、易读、易写的特性，并且对于图片、图表、数学公式等都有支援，目前许多网站都广泛使用它来撰写说明文档或是用于论坛上发表讯息，最常见的就是代码托管平台（比如国外的 Github 和国内的 Gitee）都采用 Markdown 语法来撰写 README 文件。当前，国内外比较知名的平台和大厂，也逐渐将 Markdown 作为文档标准！</p><p>此外，不管是学生、老师，亦或者是其他工作者，基本上有做笔记和码字需求的人，只要接触到 Markdown 以后，基本上都会被它的魅力折服，我们可以拿它来做笔记、演讲文稿、写博客……</p><h2 id="1-3：它的优势"><a href="#1-3：它的优势" class="headerlink" title="1.3：它的优势"></a>1.3：它的优势</h2><p>Markdown 有如下最明显的优势：</p><ol><li>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版；</li><li>纯文本，易读易写，可以方便地纳入版本控制；</li><li>让使用者可以专注于文字内容本身；</li></ol><p>举个例子，假如你想在你的文档中编辑一个一级标题和一个二级标题，那么你只需要在 Markdown 文件中键入如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是标题一</span><br><span class="line">## 这是标题二</span><br></pre></td></tr></table></figure><p>这是一段<font color=red>纯文本</font>，当把它拿到 Markdown 解析器或可以直接解释 Markdown 的编辑器中，它就是下面这个样子：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204007063.png"></p><p>一个<code>#</code>加一个空格则表示标题一，两个<code>#</code>加一个空格则表示标题二，以此类推.. 因此在 Markdown 中要想键入各个等级的标题，仅仅使用<code>#</code>和空格就可以实现了！</p><p>此外，现在一些优秀的 Markdown 编辑器，将它的编辑和解释结合，实现了更加便捷的编辑和展示效果！其中以 Typora 为代表。 在 Typora 中，当你键入<code>Ctrl</code>+<code>1</code>的快捷键，就可以在光标所在那一行（自然行，包括自动折行）的内容前面添加一个<code>#</code>及空格，直接将其设为一级标题，并且能实现“所键即所得”（能直接渲染出 Markdown 的样式而不改变 Markdown 源码）！</p><h2 id="1-4：它的局限"><a href="#1-4：它的局限" class="headerlink" title="1.4：它的局限"></a>1.4：它的局限</h2><p>Markdown 是纯文本文件，所以其本身不能存储图片，只能存储图片的链接！Markdown 插入图片的语法是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](图片路径)</span><br></pre></td></tr></table></figure><p>然后 Markdown 的编辑器在解析这段内容的时候，会自动将引用的图片放到这里，实现“图文并茂”！图片路径可以是相对路径或绝对路径，大多数情况下，我们在 Markdown 中插入图片时都是使用的相对路径，那么在传输文件的时候，若想要对方也能在该 Markdown 中看到我们插入的图片，就必须把图片也传过去，而且要求 Markdown 文件和图片所在的文件夹的相对位置不能改变，我认为这是 Markdown 目前最大的局限！</p><p><font color=red>PS</font>：我们可以使用图床来解决这个问题，但是图床不是我这篇博文的重点，故省略！</p><h1 id="第二节：基本语法"><a href="#第二节：基本语法" class="headerlink" title="第二节：基本语法"></a>第二节：基本语法</h1><p>Markdown 简洁的语法，号称半小时就可以掌握，学习成本很低，所有的语法在它的<a href="https://markdown.com.cn/intro.html">官网</a>或<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟驿站</a>中学得，我这里记录了一些我常用的 Markdown 语法，虽不全面，但是够我个人使用了，方便以后我来查询。</p><p>PS：官网提供了在线 Markdown 编辑器，在左边输入 Markdown 文本，在右边能直接展示出相应的效果，<a href="https://markdown.com.cn/editor/">网址在这</a>！</p><h2 id="2-1：标题"><a href="#2-1：标题" class="headerlink" title="2.1：标题"></a>2.1：标题</h2><p>Markdown 提供了六级标题，第 n 级标题就使用连续的 n 个<code>#</code>加上一个空格，后面跟上标题文本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 标题一</span><br><span class="line">## 标题二</span><br><span class="line">### 标题三</span><br><span class="line">#### 标题四</span><br><span class="line">##### 标题五</span><br><span class="line">###### 标题六</span><br></pre></td></tr></table></figure><p>PS：原始的 Markdown 只有三级标题，后来扩展到六级标题（因为 Markdown 的理念就是简化文本编辑，更多级的标题有悖于这个理论，所以最多只有六级标题）。</p><h2 id="2-2：斜体"><a href="#2-2：斜体" class="headerlink" title="2.2：斜体"></a>2.2：斜体</h2><p>使用一对<code>*</code>包裹的文本，会被解析为斜体：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*要斜体的文本*</span><br></pre></td></tr></table></figure><h2 id="2-3：粗体"><a href="#2-3：粗体" class="headerlink" title="2.3：粗体"></a>2.3：粗体</h2><p>使用一对<code>**</code>包裹的文本，会被解析为加粗字体：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**要加粗的文本**</span><br></pre></td></tr></table></figure><h2 id="2-4：引用"><a href="#2-4：引用" class="headerlink" title="2.4：引用"></a>2.4：引用</h2><p>对于引用的文本，可以使用<code>&gt;</code>和一个空格引出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用的文本</span><br></pre></td></tr></table></figure><h2 id="2-5：列表"><a href="#2-5：列表" class="headerlink" title="2.5：列表"></a>2.5：列表</h2><p>有序列表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. first item</span><br><span class="line">2. second item</span><br><span class="line">3. third item</span><br></pre></td></tr></table></figure><p>无序列表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- first item</span><br><span class="line">- second item</span><br><span class="line">- third item</span><br></pre></td></tr></table></figure><p>注意：<font color=red>数字或-跟后面的列表内容之间有且仅有一个空格！</font></p><h2 id="2-6：代码"><a href="#2-6：代码" class="headerlink" title="2.6：代码"></a>2.6：代码</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`code`</span><br></pre></td></tr></table></figure><p>PS：这里的符号是键盘 Tab 键上方的那个符号（英文输入模式）！</p><h2 id="2-7：链接"><a href="#2-7：链接" class="headerlink" title="2.7：链接"></a>2.7：链接</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[展示的文本](链接的地址)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;链接的地址&gt;</span><br></pre></td></tr></table></figure><p>PS：后一种方式表示展示的文本和链接的地址相同！</p><h2 id="2-8：图片"><a href="#2-8：图片" class="headerlink" title="2.8：图片"></a>2.8：图片</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](image.jpg)</span><br></pre></td></tr></table></figure><p>这里的地址可以是绝对路径或相对路径，也可以是网上任意可用的图片 URL！</p><h2 id="2-9：分隔线"><a href="#2-9：分隔线" class="headerlink" title="2.9：分隔线"></a>2.9：分隔线</h2><p>使用三个连续的<code>-</code>来表示分隔线：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="2-10：删除线"><a href="#2-10：删除线" class="headerlink" title="2.10：删除线"></a>2.10：删除线</h2><p>使用一对<code>~~</code>包裹的文本，会被添加删除线：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~文本~~</span><br></pre></td></tr></table></figure><h2 id="2-11：内嵌HTML"><a href="#2-11：内嵌HTML" class="headerlink" title="2.11：内嵌HTML"></a>2.11：内嵌HTML</h2><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用HTML本身。如需使用HTML，不需要额外标注这是HTML或是Markdown，只需HTML标签添加到Markdown文本中即可（反过来则不可以）。</p><p><font color=red><strong>第一类：行级标签</strong></font></p><p>HTML 的行级內联标签如 <code>&lt;span&gt;</code>和<code>&lt;cite&gt;</code>不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果你比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签的话，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This **word** is bold. This &lt;em&gt;word&lt;/em&gt; is italic.</span><br></pre></td></tr></table></figure><p><font color=red><strong>第二类：块状标签</strong></font></p><p>区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><p>例如，在 Markdown 文件里加上一段 HTML 表格：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is a regular paragraph.</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Foo&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">This is another regular paragraph.</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意</strong></font>：Markdown语法在HTML区块标签中将不会被进行处理，也就是说，你不能在HTML块标签中使用Markdown语法！</p><h1 id="第三节：扩展语法"><a href="#第三节：扩展语法" class="headerlink" title="第三节：扩展语法"></a>第三节：扩展语法</h1><h2 id="3-1：表格"><a href="#3-1：表格" class="headerlink" title="3.1：表格"></a>3.1：表格</h2><p>要添加表格，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列，可以选择在表的任一端添加管道：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><p>显示如下：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204048531.png"></p><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。比如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><p>显示如下：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204121309.png"></p><h2 id="3-2：脚注"><a href="#3-2：脚注" class="headerlink" title="3.2：脚注"></a>3.2：脚注</h2><p>脚注的使用频率很低，采用<code>[^数字]</code>用来表示脚注，比如在文本中使用<code>[^数字]</code>来添加一个标记：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s a sentence with a footnote. [^1]</span><br></pre></td></tr></table></figure><p>然后就可以在页脚处来表明脚注来源了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^1]: This is the footnote.</span><br></pre></td></tr></table></figure><h2 id="3-3：代码块"><a href="#3-3：代码块" class="headerlink" title="3.3：代码块"></a>3.3：代码块</h2><p>代码块使用如下的方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```代码语言</span><br><span class="line">这是代码</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>比如一段Python代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">nums = &#123;1, 2, 3&#125;</span><br><span class="line">for i in nums:</span><br><span class="line">    print(i)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="3-4：定义列表"><a href="#3-4：定义列表" class="headerlink" title="3.4：定义列表"></a>3.4：定义列表</h2><p>除了前面的有序列表和无序列表以外，我们还可以自定义列表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure><p>类似于 HTML 中的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>First Term<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>This is the definition of the first term.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Second Term<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>This is one definition of the second term. <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>This is another definition of the second term.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5：标题编号"><a href="#3-5：标题编号" class="headerlink" title="3.5：标题编号"></a>3.5：标题编号</h2><p>所谓标题编号，就是给标题自定义一个id选择器。比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 标题三 &#123;#custom-id&#125;</span><br></pre></td></tr></table></figure><p>相当于 HTML 中的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;custom-id&quot;</span>&gt;</span>标题三<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一来，其他网站中要想跳转到被编号的标题为止，可以在编号所在网页完整的 URL 后面添加<code>#custom-id</code>来链接！</p><h2 id="3-6：任务列表"><a href="#3-6：任务列表" class="headerlink" title="3.6：任务列表"></a>3.6：任务列表</h2><p>所谓任务列表，就是在一个普通列表的前面会有方括号，其中会有对号表示完成的内容，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204150715.png"></p><p>~~</p><p>~~</p><p>~~</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github使用口令替代密码来进行上传验证</title>
      <link href="/post/10021.html"/>
      <url>/post/10021.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：错误描述"><a href="#第一节：错误描述" class="headerlink" title="第一节：错误描述"></a>第一节：错误描述</h1><h2 id="1-1：报错信息"><a href="#1-1：报错信息" class="headerlink" title="1.1：报错信息"></a>1.1：报错信息</h2><p>假如你在 2021 年 8 月 13 日前后都往 Github 上提交过代码，那么在这个时间点以后，你肯定遇到过类似下面的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021.</span><br></pre></td></tr></table></figure><p>比如，我在 Github 上创建了一个新的仓库，并且用一台新的电脑第一次往这个仓库中提交代码，当提示我输入用户名和密码的时候，我照做了（且用户名和密码都输入正确），但是结果却报错：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021170548378.png"></p><h2 id="1-2：分析原因"><a href="#1-2：分析原因" class="headerlink" title="1.2：分析原因"></a>1.2：分析原因</h2><p>由报错信息可知，从 2021 年 8 月 13 日开始，Github 删除了对使用密码进行身份验证的支持！也就是说，之前你在提交代码时（第一次提交）使用 GitHub 的用户名和密码进行验证的方式已经不能使用了，用户名是指 Github 的用户名，密码则是 Github 的登录密码！</p><p>通过查阅官方文档，我发现 <font color=red>Github 现在提交代码时使用 token（口令）来替代登录密码来进行验证！</font>即使在提交代码时要求你输入的是“Password”，你依然应该输入 token 而不是 password！</p><h1 id="第二节：使用口令"><a href="#第二节：使用口令" class="headerlink" title="第二节：使用口令"></a>第二节：使用口令</h1><h2 id="2-1：创建口令"><a href="#2-1：创建口令" class="headerlink" title="2.1：创建口令"></a>2.1：创建口令</h2><p>点击 Github 主页头像，选择<code>Settings</code>，然后点击侧边栏的<code>&lt;&gt;Developer settings</code>，跳转到如下页面：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021170651466.png"></p><p>展开侧边栏的<code>Personal access token</code>，并点击<code>Token(classic)</code>：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021170914227.png"></p><p>跳转后，假如你还没有创建口令，依次点击<code>Generate new token</code> &gt; <code>Generate new token(classic)</code>：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171027238.png"></p><p>然后，对即将生成的口令进行初始化设置，比如我创建一个个人使用的永远不过期的口令：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171238531.png"></p><p>解释一下这里的设置：</p><ul><li>Note：任意填写，因为我们可能会创建很多口令，这个用来标记不同的口令，防止忘记；</li><li>Expiration：有效期，可选的有7天、30天、60天、90天、不限制，还可以自己定制时长；</li><li>Select scopes：选择范围，就是说你创建的这个口令具备的权限，勾选 repo 表示赋予仓库级别的权限；</li></ul><p>最后点击最下面的<code>Generate token</code>按钮，完成创建，页面自动生成口令：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171245030.png"></p><p>注意：口令生成以后记得保存下来，一旦离开这个页面再进来，就看不到之前生成的口令明文了</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171329123.png"></p><h2 id="2-2：使用口令"><a href="#2-2：使用口令" class="headerlink" title="2.2：使用口令"></a>2.2：使用口令</h2><p>使用口令很简单，只需要在推送代码时将其作为密码来使用即可：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171514066.png"></p><p>一旦你使用了口令以后，口令会自动保存在你的计算机缓存文件中，下次再推送的时候就不需要重复输入了。比如在 Mac 中，使用了口令以后，就可以在钥匙串中找到：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021172121473.png"></p><p>友情提示：从这里可以找到明文的口令，但是前提是你已经用口令提交过至少一次代码，所以在上面生成口令的时候一定要先复制保存起来！！！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1安装python3的最佳实践</title>
      <link href="/post/10010.html"/>
      <url>/post/10010.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：先验知识"><a href="#第一节：先验知识" class="headerlink" title="第一节：先验知识"></a>第一节：先验知识</h1><h2 id="1-1：内置python环境"><a href="#1-1：内置python环境" class="headerlink" title="1.1：内置python环境"></a>1.1：内置python环境</h2><p>一直以来，macOS 系统都有内置 python 环境的，只不过内置的都是 python2，因此在老版本的 macOS 终端中可以直接运行 python！但是从 macOS12.3 开始，macOS 系统就移除了内置的 python！</p><p>旧版本的 macOS 中，在<code>/System/Library/Frameworks</code>下面有一个名为<code>Python.framework</code>的文件夹，这个文件夹内安装的就是 python2，但是从 12.3 开始，这个文件夹被移除了，相应的内置 python 环境也不复存在！</p><p>如今，即使在新版本的 macOS 中，在<code>/usr/bin</code>下面仍然有一个名为<code>python3</code>的可执行文件：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021161936567.png"></p><p>这个文件在所有版本的 macOS 系统中都存在，只是默认情况下是没有用的，即使<code>/usr/bin</code>目录在环境变量中，但是在执行 python3 命令时仍然会提示你当前系统没有 python 环境：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162254798.png"></p><p>需要注意的是：若你安装了命令行工具——Command Line Tools，那么<code>/usr/bin/python3</code>就会“变得可用”，它会指向 CLT 内置的 python3！当我们安装完 CLT 后，在终端中：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162403085.png"></p><p>所以，没安装命令行工具时，新版本的 macOS 中是没有 python 环境的，不管是 python2 还是python3；但一旦安装了命令行工具后，macOS 自带的 <code>/usr/bin/python3</code> 就会变得可用！</p><h2 id="1-2：CLT中的python"><a href="#1-2：CLT中的python" class="headerlink" title="1.2：CLT中的python"></a>1.2：CLT中的python</h2><p>那么安装 CLT 后，python3 被安装到哪里去了呢？其实它被安装到如下的位置了：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162557148.png"></p><p>至于为什么安装命令行工具后，<code>/usr/bin/python3</code>会指向这里，那就是 macOS 底层的处理了，没必要关心！</p><h2 id="1-3：放弃内置python"><a href="#1-3：放弃内置python" class="headerlink" title="1.3：放弃内置python"></a>1.3：放弃内置python</h2><p>即然命令行工具中内置了 python3，那么安装完命令行工具后，我们还有必要去自己安装 python3 吗？答案是：肯定有必要！为什么这么说呢，我个人认为主要有如下两个原因。</p><p>第一：命令行工具自带的 python3 是简化版的，版本较低，而且不会附带官方文档和 IDLE 等；而自己安装的话，不仅可以自由选择版本，而且还可以附带文档和 IDLE 等。</p><p>第二：使用命令行工具自带的<code>python3</code>可能会出现意料之外的问题。比如<code>pip3</code>的更新问题，直接更新的话，会在用户目录下生成<code>site-packages</code>文件夹，这样一来系统中就有了两个<code>site-packages</code>文件夹了；假如绕开权限（使用<code>sudo</code>前缀）来更新的话，虽然可以卸载旧版本的<code>pip3</code>，但是在安装新的<code>pip3</code>时，会在<code>/Library</code>中产生名为<code>Python</code>的文件夹，并在其中继续生成<code>site-packages</code>文件夹，并没有将新的<code>site-packages</code>文件夹放到旧版<code>site-packages</code>的位置，此外还会在<code>/usr/local/bin</code>中生成<code>pip3</code>和<code>pip</code>。虽然都不影响使用，但这无形之中在系统中添加了好多零零散散的目录，看起来很烦！假如后面产生和依赖相关的问题，势必会对定位问题产生不必要的困扰。</p><p>综合以上两点，我最终放弃了命令行内置的 python3，在我日常的开发中，我选择使用自己安装的 python3！<font color=red>友情提示</font>：假如你将命令行内置的 python3 作为基础环境，每次都是使用它来创建虚拟环境，然后在项目中继续使用的是你创建的虚拟环境，那命令行工具中内置的 python3 还是可以用的！</p><h1 id="第二节：下载安装"><a href="#第二节：下载安装" class="headerlink" title="第二节：下载安装"></a>第二节：下载安装</h1><h2 id="2-1：版本选择"><a href="#2-1：版本选择" class="headerlink" title="2.1：版本选择"></a>2.1：版本选择</h2><p>虽然 Python 官网说 3.9.1 已经原生支持 M 系列的芯片了，但我从官方下载了 3.9.1，在安装的过程中还是会提示我安装转译器 Rosetta！并且从 3.9.1 开始逐个地尝试，直到 3.9.10 开始（包括 3.9.10），在安装的过程中才不会提示我安装转译器！所以干脆我就选择了 3.9 的最后一个带有<code>.pkg</code>安装程序的版本——3.9.13！</p><p>登陆官网，找到 3.9.13 的下载链接，选择合适的版本来下载：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162916925.png"></p><p>下载下来的是一个<code>.pkg</code>格式的安装程序！</p><h2 id="2-2：安装步骤"><a href="#2-2：安装步骤" class="headerlink" title="2.2：安装步骤"></a>2.2：安装步骤</h2><p>双击安装包，进行傻瓜式安装即可！需要注意的是，安装过程中有个“自定”的选择，不要取消勾选，使用标准安装即可：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163226399.png"></p><p>安装完成以后，点击安装程序的“关闭”按钮，会自动跳出如下页面：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163354072.png"></p><p>这说明：安装程序会在<code>/Application</code>下面生成一个名为“Python 3.9”的文件夹，文件夹中的内容如上图所示！</p><h2 id="2-3：验证结果"><a href="#2-3：验证结果" class="headerlink" title="2.3：验证结果"></a>2.3：验证结果</h2><p>在安装之前是这样的：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162403085.png"></p><p>而在安装之后是这样的：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163603311.png"></p><p>可见，此时我们系统默认的 python3 是我们手动安装的 3.9.13，而不是之前系统默认的 3.9.6（CLT 中内置的）！这就说明我们的安装是成功的！安装的位置就是<code>/library/Frameworks/Python.framework</code>目录！</p><h2 id="2-4：安装位置"><a href="#2-4：安装位置" class="headerlink" title="2.4：安装位置"></a>2.4：安装位置</h2><p>通过在终端中执行<code>which python3</code>命令，我们可以看到安装的python位置：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163715058.png"></p><p>假如要卸载的话，首先要删除的就是<code>/Library/Frameworks/Python.framework</code>文件！</p><h2 id="2-5：环境变量"><a href="#2-5：环境变量" class="headerlink" title="2.5：环境变量"></a>2.5：环境变量</h2><p>使用安装程序来安装的 python3，是不需要配置环境变量的！为什么呢？</p><p>打开用户目录下的<code>.zprofile</code>文件，可见：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164102199.png"></p><p>假如你用户目录下原本没有这个文件，安装完以后也会自动生成这个文件并将上图红框内的内容写入！这个内容的意思就是把用户安装的 python 命令放到系统 PATH 变量的最前面：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164207519.png"></p><p>那<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中都有哪些命令呢？如下：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164320944.png"></p><p>所以此时我们不需要配置环境变量，因为位于<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中的这些命令已经被放到系统 PATH 变量的最前面了！</p><h2 id="2-6：符号连接"><a href="#2-6：符号连接" class="headerlink" title="2.6：符号连接"></a>2.6：符号连接</h2><p>安装程序还会在<code>/usr/local/bin</code>目录下创建一些符号链接，这些链接指向安装的命令：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164555245.png"></p><p>而<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中安装的这些命令原本就已经在系统的 PATH 中了，而且<code>/usr/local/bin</code>还在<code>/usr/bin</code>（命令行内置 python3 命令所在位置）的前面，再一次保证了我们不需要自己配置环境变量！</p><h1 id="第三节：更新-pip3"><a href="#第三节：更新-pip3" class="headerlink" title="第三节：更新 pip3"></a>第三节：更新 pip3</h1><h2 id="3-1：系统中的pip3"><a href="#3-1：系统中的pip3" class="headerlink" title="3.1：系统中的pip3"></a>3.1：系统中的pip3</h2><p>不管是通过命令行工具安装的还是我们自己通过安装程序安装的 python3，都会自带 pip3：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164730052.png"></p><p>显然，当前系统默认的 pip3 是我们自己安装的 python3 中的！</p><p>注意：跟 python 一样，在终端中使用 pip 的时候也需要使用<code>pip3</code>来替代<code>pip</code>，使用<code>pip</code>是无效的</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164908982.png"></p><h2 id="3-2：查看依赖"><a href="#3-2：查看依赖" class="headerlink" title="3.2：查看依赖"></a>3.2：查看依赖</h2><p>使用<code>pip3 list</code>可以查看当前 python3 环境都安装了哪些第三方库：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164843080.png"></p><p>注意：这个命令只能检测到当前 python3 环境可以使用的第三方库和模块，不包括内建的和标准的！</p><p>可见当前我们的 pip3 中只有两个库，一个是 pip3 本身，另外一个 setuptools 是支持 pip3 的：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021165049108.png"></p><p>记住 site-packages 这个路径，后面我们通过 pip3 下载安装的第三方库和模块都会被放到这里！</p><h2 id="3-3：最终做法"><a href="#3-3：最终做法" class="headerlink" title="3.3：最终做法"></a>3.3：最终做法</h2><p>跟命令行工具内置的 pip3 一样，使用安装程序安装的 python3 内置的 pip3 的版本也不是最新的，同样需要更新：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164843080.png"></p><p>回忆：我们尝试更新命令行工具自带的 pip3 时，会有如下问题</p><ul><li>直接更新的话，因为的权限问题，首先会导致原本的 pip3 卸载不掉，其次会将新的 pip3 安装到用户目录下，虽然不影响使用，但此时系统中会存在两个 site-packages 文件夹，当前 python3 可以使用这两个文件夹中的资源；</li><li>使用<code>sudo</code>来更新的话，虽然可以将原本的 pip3 卸载，但却没有把新版的 pip3 安装到旧版的 pip3 位置，而是安装到了<code>/Library/Python/site-packages</code>中了，并且会在<code>/usr/local/bin</code>中生成 pip3 和 pip 命令指向这里。假如这样的话，那么以后每次使用 pip3 都要在前面加上<code>sudo</code>，而且安装最后系统还是会给出提示“Running pip as the ‘root’ user can result in broken permissions and conflicting behaviour with the system package manager”，所以最终放弃这种方案；</li></ul><p>而更新自己安装的 python3 中自带的 pip3 时，就不会遇到这样的问题，直接使用终端中提示的命令就可以更新成功！</p><p><font color='red'>但是，更新以后终端中可以同时识别“pip3”和“pip”这两个命令</font>！这是因为新版的 pip 会同时安装<code>pip</code>和<code>pip3</code>两个命令，所以我干脆就不更新了，理由有三：</p><ul><li>不更新也能使用，又不是必须的，只是会出现更新的提示；</li><li>今后不打算直接使用系统默认的 python3，而是用它来创建虚拟环境（即使更新了系统默认的 pip3，创建的虚拟环境对应的 pip3 依然是新安装时未更新的 pip3 版本，所以从这方面看，更新 pip3 也是没必要的）；</li><li>在 macOS 上，我更愿意用“pip3”而非“pip”（因为在命令行中我们也只能使用“python3”而不是“python”，就要整整齐齐，装逼就要装个整套的）；</li></ul><h1 id="第四节：总结归纳"><a href="#第四节：总结归纳" class="headerlink" title="第四节：总结归纳"></a>第四节：总结归纳</h1><h2 id="4-1：安装所得"><a href="#4-1：安装所得" class="headerlink" title="4.1：安装所得"></a>4.1：安装所得</h2><p>在整个手动安装 python3 的过程中，安装程序总共做了下面几件事：</p><ul><li><p>生成<code>/Application/Python 3.9</code>文件；</p></li><li><p>生成<code>/Library/Frameworks/Python.framework</code>文件，这是实际安装的 python3 文件；</p></li><li><p>生成<code>~/.zprofile</code>文件，将安装的 python3 添加到环境变量中；</p><p>假如系统中原本就有这个文件，就会在文件末尾追加配置环境的内容</p></li><li><p>生成一些链接，在<code>/usr/local/bin</code>中；</p><p>这些链接指向<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中的命令；</p></li></ul><p>假如要卸载的话，只需要去复原上面这四项即可！</p><h2 id="4-2：系统环境"><a href="#4-2：系统环境" class="headerlink" title="4.2：系统环境"></a>4.2：系统环境</h2><p>经过安装命令行工具 CLT 和手动安装 python 3.9.13，此时系统中有两个版本的 python3 环境：</p><ul><li>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;Library&#x2F;Frameworks&#x2F;Python3.framework&#x2F;Versions&#x2F;3.9</li><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9</li></ul><p>前者是命令行工具中内置的，后者是我们手动安装的，而且此时如下的 python3 命令都是指我们自己安装的：</p><ul><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9</li><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.9</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3</li></ul><p>而如下的 pip3 指向我们手动安装的 pip3：</p><ul><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3.9</li><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.9</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3</li></ul><p>此时，在终端中直接使用 pip3 命令来安装依赖时，依赖会被安装到如下目录：</p><ul><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;site-packages</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Python </tag>
            
            <tag> 命令行工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在macOS上安装配置Nodejs的保姆级教程</title>
      <link href="/post/10009.html"/>
      <url>/post/10009.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：什么是-Nodejs"><a href="#第一节：什么是-Nodejs" class="headerlink" title="第一节：什么是 Nodejs?"></a>第一节：什么是 Nodejs?</h1><blockquote><p>简单来说：Nodejs 是一个基于 Chrome V8 开发的 JavaScript 的运行环境，能够使 JavaScript 脱离浏览器运行！</p></blockquote><p>Node.js 是 2009 的时候由大神 Ryan Dahl 开发的。Ryan 的本职工作是用 C++ 写服务器，后来他总结出一个经验，一个高性能服务器应该是满足“事件驱动，非阻塞 I&#x2F;O”模型的。C++ 开发起来比较麻烦，于是 Ryan 就想找一种更高级的语言，以便快速开发。</p><p>可以说有两点促成了 Nodejs 的诞生。首先第一点，Ryan 发现 JS 语言本身的特点就是事件驱动并且是非阻塞 I&#x2F;O 的，跟他的思路正是绝配；第二点，Chrome 的 JS 引擎，也就是 V8 引擎是开源的，而且性能特别棒。于是 Ryan 就基于  Chrome V8 开发了 Node.js 。</p><p>注意：Node.js 听起来好像是个 JS 库，其实不是的，Node.js 是使用 C++ 开发的，到官网 <a href="https://link.zhihu.com/?target=http://nodejs.org">http://nodejs.org</a> 可以看到！所以说：<font color='red'>Node.js不是库，而是一个运行环境，或者说是一个JS语言解释器！</font></p><h2 id="1-1：执行JS代码"><a href="#1-1：执行JS代码" class="headerlink" title="1.1：执行JS代码"></a>1.1：执行JS代码</h2><p>以前 JavaScript 只能运行在浏览器中，Node.js 出现之后，不管是服务器上还是我们自己的笔记本，只要是你安装了 Nodejs，就可以运行 JavaScrip t代码了！</p><p>比如，安装完 Nodejs 以后，进入命令行以后执行命令<code>node</code>进入 Nodejs 环境以后，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 1</span><br></pre></td></tr></table></figure><p>这段JS代码就是简单的执行加法操作，回车后就可以看到代码正确执行了。</p><p>跟 python 相同，我们还可以将JS代码编写在<code>.js</code>文件中，然后使用 Nodejs 环境直接执行改文件。比如在<code>test.js</code>文件中编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在命令行中这样执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><p>此时“hello”会被打印出来，而这种执行过程跟浏览器没有一毛钱关系，<font color='red'>Nodejs使得JS代码脱离了浏览器的限制！</font></p><p>PS：当然 Nodejs 跟浏览器还是有一些细微的区别的，这里我们先不关注。</p><h2 id="1-2：内置包管理器"><a href="#1-2：内置包管理器" class="headerlink" title="1.2：内置包管理器"></a>1.2：内置包管理器</h2><p>Nodejs 的出现，引发了前后端开发的爆发（尤其是前端），众多的JS开发者贡献了非常多的开源代码，所有这些优秀的代码就凝结成了一个仓库——世界上最大的包管理器 npm！</p><p>不知道在座的各位有没有用过 Python，Python 有一个很优秀的包管理器 pip，通过 pip 我们可以获取其他 Python 开发者写好的优秀代码，并将其引用到我们自己的项目中来。npm 同样如此，它是 Nodejs 的包管理器，通过 npm 我们可以简单的获取其他开发者的优秀代码，并将其引用到我们的项目中，避免“重复造轮子”！<font color='red'>跟 pip 一样，npm 既是一个代码库，也是一个程序，当系统安装上 Nodejs 以后，会内置安装 npm</font>！</p><p>比如，安装完 Nodejs 后，我们想使用 npm 安装一个名为 moment 的代码库，就可以直接执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br></pre></td></tr></table></figure><p>这个命令可以直接把 moment 这个包从 npm 的软件包仓库中下载这个包并安装到本地，而在 npm 仓库中还有这数以万计的类似 moment 这样的包！</p><p>关于 npm ，我们暂时理解到这个程度就可以了，只要求会用！</p><h1 id="第二节：下载安装"><a href="#第二节：下载安装" class="headerlink" title="第二节：下载安装"></a>第二节：下载安装</h1><h2 id="2-1：下载"><a href="#2-1：下载" class="headerlink" title="2.1：下载"></a>2.1：下载</h2><p>浏览器访问<a href="https://nodejs.org/">Nodejs的官网</a>：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021152549673.png"></p><p>PS：LTS 版本是长期维护的稳定版本，Current 是当前开发版本，一般情况下，我们选择 LTS 版本的下载。</p><p>也可以通过 Downloads 页签找到更多的选择，比如我选择的是同时支持 Intel 和苹果 Silicon 的 macOS 安装程序：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021152853040.png"></p><p>PS：如此流行的 Nodejs，比其他开发环境更早的适配 ARM 架构（真的很牛逼，很多比较常用的开发环境对于 ARM 架构的支持都是比较滞后的），这对使用苹果芯片的 macOS 用户来说简直是太棒了！下载下来的是一个<code>.pkg</code>的安装程序。</p><h2 id="2-2：安装"><a href="#2-2：安装" class="headerlink" title="2.2：安装"></a>2.2：安装</h2><p>直接双击下载下来的安装程序，进入安装程序：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153158616.png"></p><p>友情提示：</p><ul><li><p>安装程序会安装 node，并将其安装到<code>/usr/local/bin/node</code>目录；</p></li><li><p>安装程序会安装 npm，并将其安装到<code>/usr/local/bin/npm</code>目录；</p></li><li><p>假如你此前没使用过<code>/usr/local</code>目录的话，此时这个目录应该是空的（比如我在安装前，这个目录就是空的）；</p></li></ul><p>点击上图中右下角的“继续”，会展示软件许可协议：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153353254.png"></p><p>点击上图中的“继续”：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153507248.png"></p><p>然后点击上图中的“同意”：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153623806.png"></p><p>假如此时点击“自定”，我们看到安装程序会安装 Node.js 和 npm：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153715916.png"></p><p>这里不需要修改，直接点击“安装”，输入机器开机密码后，即可进入自动安装！最后点击“关闭”来完成安装：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153859069.png"></p><h2 id="2-3：配置"><a href="#2-3：配置" class="headerlink" title="2.3：配置"></a>2.3：配置</h2><p>为了能在命令行中使用 Nodejs，我们需要确认安装的 node 和 npm 在我们的系统的环境变量 PATH 中。但是这两者的安装位置<code>/usr/local/bin/</code>本身就在 Mac 的环境变量 PATH 中，这是系统预置的：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154036625.png"></p><p><font color='red'>也就是说：使用安装程序安装的Nodejs，不需要我们再自己手动的设置环境变量了！</font></p><h2 id="2-4：检查"><a href="#2-4：检查" class="headerlink" title="2.4：检查"></a>2.4：检查</h2><p>打开终端，查看 node 和 npm 的版本号，假如能正确查看到版本号，则说明安装成功：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154420969.png"></p><h2 id="2-5：-npm"><a href="#2-5：-npm" class="headerlink" title="2.5：.npm"></a>2.5：.npm</h2><p>安装 Nodejs 获得的文件：</p><ul><li>安装的 Nodejs 的所有的文件都安装到<code>/usr/local</code>目录中（这个目录原本是空的）；</li><li>安装完 Nodejs 后，用户目录下没有<code>.npm</code>文件，执行<code>npm</code>命令后，用户目录下会产生名为<code>.npm</code>的隐藏文件；</li></ul><p>刚安装 Nodejs 后，用户目录下有如下文件：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154318574.png"></p><p>当执行了 2.4 中的<code>npm</code>命令后，就会再用户目录下生成名为<code>.npm</code>的文件：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154529947.png"></p><p>友情提示：</p><ul><li>因为<code>npm</code>命令在环境变量中，所以可以在任意目录下执行<code>npm</code>命令；</li><li>无论在哪个目录下执行<code>npm</code>命令，都会在用户目录下生成名为<code>.npm</code>的隐藏文件！</li></ul><h1 id="第三节：额外配置"><a href="#第三节：额外配置" class="headerlink" title="第三节：额外配置"></a>第三节：额外配置</h1><p>当使用 npm 来安装第三方软件包的时候，有局部安装和全局安装两种安装类型，对应的命令分别是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install 软件包名</span><br><span class="line">npm install -g 软件包名</span><br></pre></td></tr></table></figure><p>前者表示局部安装，后者表示全局安装！使用“<font color='red'>npm root</font>”命令可以查看局部安装和全局安装的目标目录：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154657299.png"></p><p>友情提示：</p><ul><li>局部安装时，软件包会被安装到执行安装命令的目录下（假如执行安装命令的路径下有<code>node_modules</code>），或者被安装到当前用户目录下的<code>node_modules</code>文件夹中（假如执行安装命令的路径下没有<code>node_modules</code>）；</li><li>全局安装时，软件包会被安装到<code>/usr/local/lib/mode_modules</code>文件夹中；</li></ul><h2 id="3-1：局部安装"><a href="#3-1：局部安装" class="headerlink" title="3.1：局部安装"></a>3.1：局部安装</h2><p>在局部安装之前，用户目录下的文件目录是这样的（用户目录下的<code>.npm</code>文件是只要执行<code>npm</code>命令就会产生的）：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154809551.png"></p><p>下面，我们试着在用户目录下局部安装一个名为<code>moment</code>库，在用户目录下执行<code>npm install moment</code>：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154902742.png"></p><p>PS：其实安装的时候，终端中会有进度条展示，但是网速比较快的话，基本捕捉不到进度条！</p><p>此时查看用户目录，可见这里会产生三个新的文件（用户目录下的<code>.npm</code>文件是只要执行<code>npm</code>命令就会产生或更新）：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155002595.png"></p><p><font color=red>友情提醒</font>：其中安装的 moment 包就放在<code>node_modules</code>文件夹中，使用<code>npm uninstall moment</code>命令卸载时，只会将<code>~/node_modules/</code>中的<code>moment</code>文件夹删掉，上图中新生成的这三个文件夹不会被删除！</p><p><font color='red'><strong>综上</strong></font>：</p><ul><li>使用局部安装的方式，不需要额外的任何配置；</li><li>局部安装时，软件包会被安装到执行安装命令的目录下（假如执行安装命令的路径下有<code>node_modules</code>），或者被安装到当前用户目录下的<code>node_modules</code>文件夹中（假如执行安装命令的路径下没有<code>node_modules</code>）；</li></ul><h2 id="3-2：全局安装"><a href="#3-2：全局安装" class="headerlink" title="3.2：全局安装"></a>3.2：全局安装</h2><p>局部安装时，会在安装目录下生成<code>node_modules</code>目录，但是全局安装的目标目录<code>/usr/local/lib/node_modules</code>本身就存在（package-local.json 和 package.json不存在），并且里面本身就存在两个包（这是自带的两个包）：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155518502.png"></p><p>直接执行命令<code>npm install -g moment</code>来全局安装 moment 包：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155406170.png"></p><p>执行报错！因为执行全局安装时，npm 会默认将软件包安装到<code>/usr/local/lib/node_modules/</code>目录下，但是从<code>/usr</code>到<code>/usr/local/lib/node_modules/</code>这些目录的权限全是<code>drwxr-xr-x</code>，并且权限属主是 root、属组是 wheel！</p><p>PS：macOS 系统的权限控制</p><ul><li>macOS 系统中有 staff、admin、wheel 这三种用户组；</li><li>staff：所有的用户都属于这个组，这是用户的一个超集；</li><li>admin：这个组中的用户可以使用<code>su</code>或<code>sudo</code>切换到 root 用户，只需要输入自己的密码即可，不用 root 密码；</li><li>wheel：这个组只有一个 root 用户，是 root 用户的专属组；</li></ul><p>所以，对于<code>drwxr-xr-x</code>而言，正常情况下 admin 用户对它不具备写的权限！这也是为什么上面会报错的原因！</p><p>解决这个问题，有两种思路：</p><ul><li><p>方法一：使用<code>sudo npm install -g moment</code>命令代替<code>npm install -g moment</code></p><p>  root 用户对<code>/usr/local/lib/node_modules/</code>有写的权限，所以使用<code>sudo</code>让管理员用户暂时具备 root 用户的权限，这样就可以完成安装了！虽然这样可以成功安装软件包到<code>/usr/local/lib/node_modules/</code>中，但是这种方式是不可取的！因为<code>sudo</code>只对当前命令有效，假如我们执行的是更新语句的话，分为卸载和安装两个步骤，<code>sudo</code>只对卸载旧版本有效，对安装新版本就无效了，所以不能使用这种方式；</p><p>  <font color=red>我们在使用 npm 进行全局安装时，应该尽量避免甚至完全不用<code>sudo</code>！</font></p></li><li><p>方法二：修改<code>/usr/local/lib/node_modules/</code>的权限，让其他用户（包括 admin）对该目录具备写权限</p><p>  因为 admin 对<code>node_modules</code>的所有上级目录都具备可执行权限，在这种情况下，只要它再对<code>node_modules</code>具备写的权限，那么 admin 就可以写这个目录了，这是 Linux 的权限机制！</p><p>  <font color=red>显然这种方式更可取，这样在安装的时候就可以不用<code>sudo</code>了，而且可以一劳永逸！</font></p></li></ul><p>具体的操作步骤：</p><ol><li><p>打开终端，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 757 /usr/local/lib/node_modules</span><br></pre></td></tr></table></figure><p>这一步是为了让 admin 用户对<code>/usr/local/lib/node_modules/</code>具备写的权限！</p></li><li><p>打开终端，继续执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 757 /usr/local/bin</span><br></pre></td></tr></table></figure><p>因为在全局安装时，经常需要在<code>/usr/local/bin</code>中创建一些软连接，并让它们指向下载的包中的真实的命令，所以我们同时需要让当前用户（admin）对<code>/usr/local/bin</code>也具备写的权限！这一步就是做这个的。</p></li></ol><p>经过这两个命令以后，使用全局安装的时候，就能轻松地将软件包安装到<code>/usr/local/lib/node_modules/</code>中了，并且伺候不管是下载、安装还是更新，都能一劳永逸！比如此时我全局安装 moment 包就可以成功：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155805416.png"></p><p><font color='red'><strong>综上</strong></font>：安装完 Nodejs 后，使用全局安装之前，需要使用如下两个命令来改变文件的权限，仅此而已</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 757 /usr/local/lib/node_modules</span><br><span class="line">sudo chmod 757 /usr/local/bin</span><br></pre></td></tr></table></figure><p>在使用 npm 全局安装包的时候，就单纯的安装操作而言，我们直接使用<code>sudo</code> 配合<code>-g</code>参数就可以安装完成，后续也不影响对所安装软件包的使用（因为管理员用户对这个目录具备读的权限），但是为了简化每一次的安装和卸载，所以我修改了<code>/usr/local/lib/node_modules/</code>的权限；其次，为了能顺利在<code>/usr/local/bin</code>中创建能指向安装包中的命令的软连接，还需要修改<code>/usr/local/bin</code>的权限。二者缺一不可，一劳永逸！</p><p>全局安装时，包会被安装到<code>/usr/local/lib/node_modules/</code>目录下（目录本就存在，但要修改该权限）；</p><p><font color='red'><strong>注意</strong></font>：全局安装的包，在卸载时也需要使用<code>-g</code>参数来全局卸载！</p><h2 id="3-3：换镜像源"><a href="#3-3：换镜像源" class="headerlink" title="3.3：换镜像源"></a>3.3：换镜像源</h2><p>所谓 npm 镜像源，就是指使用<code>npm</code>命令来安装包的时候，通过网络下载的包的来源。</p><p>执行命令<code>npm config get registry</code>可以查看 npm 的镜像源，默认的镜像源是：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155905051.png"></p><p>默认的镜像源是国外的，有时候我们在国内使用 npm 默认的镜像源时，会因为网络问题导致失败。在这种情况下我们可以更换为国内的镜像源，常见的 npm 镜像源有如下三种：</p><ul><li>腾讯镜像源：<a href="http://mirrors.cloud.tencent.com/npm/">http://mirrors.cloud.tencent.com/npm/</a></li><li>淘宝镜像源：<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>华为镜像源：<a href="https://mirrors.huaweicloud.com/repository/npm/">https://mirrors.huaweicloud.com/repository/npm/</a></li></ul><p>此外，更换镜像源的方式有两种：</p><ul><li><p><font color='red'>暂时修改镜像源</font></p><p>比如使用淘宝源全局下载 moment，可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npmmirror.com install -g moment</span><br></pre></td></tr></table></figure><p>这种方式不会修改 npm 默认的镜像源，下次使用<code>npm install</code>命令来安装时，依然使用 npm 默认的镜像源！而卸载的时候就不需要指定镜像源了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g moment</span><br></pre></td></tr></table></figure></li><li><p><font color='red'>永久修改镜像源</font></p><p>我们可以永久修改 npm 镜像源，这样一来每次都可以使用我们配置的镜像源来下载，而不用指定镜像源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>对 npm 进行了自己的配置后，会在用户目录下生成名为<code>.npmrc</code>的隐藏文件，以“key&#x3D;value”的形式记录配置！</p><p>注意这里不要添加<code>-g</code>参数，如果添加了的话，就只是修改了全局安装时的镜像源，局部安装的镜像源没有修改！</p></li></ul><p>PS：我们还可以使用 npm 安装 cnpm，因为 cnpm 默认使用淘宝源，但我不推荐，因为 cnpm 的安装目录比较奇怪！</p><h2 id="3-4：更新npm"><a href="#3-4：更新npm" class="headerlink" title="3.4：更新npm"></a>3.4：更新npm</h2><p>一般 Nodejs 中自带的 npm 不是最新的，需要更新 npm。比如前面我第一次使用 npm 安装 moment 时，就给出了提示：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154902742.png"></p><p>当然，假如你第一次忽略了这个版本提醒，后面再使用时就不会给出版本提醒了，除非你删除了用户目录下的<code>.npm</code>文件后再执行<code>npm</code>命令！</p><p>我们可以使用命令如下命令来查看当前 npm 的最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view npm version</span><br></pre></td></tr></table></figure><p>比如我这里：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021160311613.png"></p><p>但是此时若直接执行更新命令<code>npm install -g npm@10.2.1</code>的话，会出现错误：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021160839704.png"></p><p>其实这里的问题跟本文 3.2 中的情况是相同的，同样需要处理权限问题，我这里就不再赘述了（我觉得其实也没必要更新它，只要不删除用户目录下的<code>.npm</code>文件的话，以后在使用它的时候不会再提示更新）！</p><h1 id="第四节：常用命令"><a href="#第四节：常用命令" class="headerlink" title="第四节：常用命令"></a>第四节：常用命令</h1><p>npm 的命令都采用<code>命令</code>+<code>参数</code>的形式！</p><h2 id="4-1：帮助"><a href="#4-1：帮助" class="headerlink" title="4.1：帮助"></a>4.1：帮助</h2><p>在 npm 中，有一个最重要的命令，就是<code>npm help</code>，这个命令可以查看所有其他 npm 命令的用法：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021161452100.png"></p><p>假如要查看某个特定命令的用法，可以使用<code>npm help 命令</code>，比如查看<code>config</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm help config</span><br></pre></td></tr></table></figure><h2 id="4-2：配置"><a href="#4-2：配置" class="headerlink" title="4.2：配置"></a>4.2：配置</h2><ul><li><p>使用<code>npm config key=value</code>进行配置，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=https://registry.npmmirror.com  # 这里的等号也可以用空格替代</span><br></pre></td></tr></table></figure></li><li><p>使用<code>npm config get key</code>查看配置，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry # 假如要查看多个，可以用空格隔开</span><br></pre></td></tr></table></figure></li></ul><p>所有的使用细节，可以使用<code>npm config --help</code>来查看大概用法，使用<code>npm help config</code>来查看详细用法！</p><h2 id="4-3：安装"><a href="#4-3：安装" class="headerlink" title="4.3：安装"></a>4.3：安装</h2><p>安装指定包，默认是局部安装，<code>-g</code>参数表示全局安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [-g] package</span><br></pre></td></tr></table></figure><h2 id="4-4：更新"><a href="#4-4：更新" class="headerlink" title="4.4：更新"></a>4.4：更新</h2><p>更新指定包，默认是局部更新，<code>-g</code>参数表示全局更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update [-g] package</span><br></pre></td></tr></table></figure><h2 id="4-4：卸载"><a href="#4-4：卸载" class="headerlink" title="4.4：卸载"></a>4.4：卸载</h2><p>卸载指定包，默认是局部卸载，<code>-g</code>参数表示全局卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall [-g] package</span><br></pre></td></tr></table></figure><h2 id="4-5：查看"><a href="#4-5：查看" class="headerlink" title="4.5：查看"></a>4.5：查看</h2><p>查看当前安装的软件包，默认查看局部安装的软件包，<code>-g</code>参数表示查看全局安装的软件包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list [-g]</span><br></pre></td></tr></table></figure><p>查看软件包的安装位置，默认是查看局部安装位置，<code>-g</code>参数表示查看全局安装位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root [-g]</span><br></pre></td></tr></table></figure><p>查看具体某个软件包的安装位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root package</span><br></pre></td></tr></table></figure><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Nodejs </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew的安装配置和使用</title>
      <link href="/post/10008.html"/>
      <url>/post/10008.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><p>Homebrew 是 macOS 平台上最常用也是最好用的一个包管理工具，使用它给 Mac 下载、安装、卸载软件时，基本上都只需要一条命令，如果你是一位使用Mac的开发者，还没有安装Homebrew的话，那就太不应该了！</p><p>这里我要先声明两点：</p><ul><li><p>英特尔芯片的 Mac 安装 Homebrew 是很简单的，默认安装位置是<code>/usr/local</code>，我这里就不再赘述了；</p></li><li><p>苹果芯片的 Mac 刚出来的时候，安装 Homebrew 是比较复杂的。第一，是因为默认安装的目录跟 英特尔芯片的电脑不同，默认安装的位置是<code>/opt/homebrew</code>；第二，是需要处理一些文件夹的权限问题，但随着 Homebrew 的版本更新，虽然默认的安装位置没变，但是截止到我写这篇博文的时间，也就是 2023 年 9 月 8 日，已经不需要再额外处理权限问题了！</p></li></ul><p>这篇博文详细记录了如何在苹果芯片的 macOS 上安装和使用支持 ARM 架构的 Homebrew！</p><h1 id="第二节：检测环境"><a href="#第二节：检测环境" class="headerlink" title="第二节：检测环境"></a>第二节：检测环境</h1><p>在安装 Homebrew 之前，首先查看目录<code>/opt/</code>下面没有名为<code>homebrew</code>的子目录，我这是一台新电脑，显然没有：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021132854441.png"></p><p>其次，还需要在终端中执行命令<code>brew --version</code>来检测是否存在 Homebrew，当然也不会有的：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021133045993.png"></p><p>综合以上两点，说明当前环境中并没有安装 Homebrew！就算不是新的电脑，假如满足这两个条件，我们也可以认为当前系统中不存在 Homebrew！</p><p>PS：在安装软件之前检测本机是否已经安装了要安装的软件，这是一个必要的操作，也是一个好习惯！</p><h1 id="第三节：安装条件"><a href="#第三节：安装条件" class="headerlink" title="第三节：安装条件"></a>第三节：安装条件</h1><p>打开<a href="https://brew.sh/index_zh-cn">Homebrew的官网</a>，首页赫然展示的就是安装 Homebrew 的命令：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021133925788.png"></p><p>其实，只需要将这里的命令复制到终端中执行，即可完成安装。但是在安装之前，点击上图中的<code>这里</code>，可见：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021144620878.png"></p><p>这是安装 Homebrew 时，macOS 需要满足的条件：</p><ul><li>搭载 Intel 芯片或苹果芯片的 macOS（废话）；</li><li>macOS 的版本至少要在 11 以上；</li><li>必须提前安装命令行开发者工具（CLT）；</li><li>必须使用Bourne-again shell（Bash）终端来安装，Mac 是自带 bash 终端的，即<code>/usr/bin/bash</code>；</li></ul><p>其中有这么一条：<font color='red'>必须提前安装命令行开发者工具</font>！命令行开发者工具是将Mac作为开发工具的第一步操作，我不信还有人的Mac没有安装 CLT！！！</p><h1 id="第四节：安装程序"><a href="#第四节：安装程序" class="headerlink" title="第四节：安装程序"></a>第四节：安装程序</h1><p>在官网上，安装条件的第四条说明了，必须使用 bash，使用其他常规的 shell 将会失败：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021144956117.png"></p><p><font color=red>友情提示</font>：较新版本的 macOS 终端默认使用的是 zsh（包括我这里的 14.0），我试过使用 zsh 安装，结果是也能安装成功，我觉得是 Homebrew 的官网上信息很久没更新了，因为较老版本的 macOS 的终端默认是使用 bash 的，现在已经默认使用 zsh 了！但是为了保险起见，我还是使用<code>/bin/bash</code>来执行安装的命令！</p><p>打开访达，切换到<code>/bin</code>，右击<code>bash</code>选择使用终端打开，再把官网上的安装命令贴进去：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145241014.png"></p><p>按下回车需要输入开机密码：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145345605.png"></p><p>输入密码并回车（注意输入密码的时候，键入的密码并不会出现在终端中，你只管正确输入即可）后，开始安装：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145511355.png"></p><p>此时键入回车键，继续安装，直到最后安装成功：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145709620.png"></p><p>从这里可以看出来，Homebrew安装成功了！查看目录<code>/opt</code>中的内容，可以看到安装的 Homebrew：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145953498.png"></p><h1 id="第五节：配置环境"><a href="#第五节：配置环境" class="headerlink" title="第五节：配置环境"></a>第五节：配置环境</h1><h2 id="5-1：官方推荐"><a href="#5-1：官方推荐" class="headerlink" title="5.1：官方推荐"></a>5.1：官方推荐</h2><p>安装 Homebrew 前后，macOS 的系统 PATH 变量没有任何变化：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150312442.png"></p><p>安装程序的最后给出提示，安装的 Homebrew 并不在我们的环境变量中，并且还给出了如何配置环境变量的方法：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150433799.png"></p><p>将推荐中的两条命令复制下来依次拿到终端中去执行就能配置环境变量了，之后会在用户目录下生成名为<code>.zprofile</code>的配置文件，文件内容为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure><p>然后使用命令<code>echo $PATH</code>查看系统的 PATH 变量的话，会再原本 PATH 变量的最前面，添加如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/homebrew/bin:/opt/homebrew/sbin:</span><br></pre></td></tr></table></figure><p><font color='red'><strong>说明</strong></font>：文件<code>.zprofile</code>中的内容就是把<code>/opt/homebrew/bin</code>和<code>/opt/homebrew/sbin</code>加到系统 PATH 里面了！</p><h2 id="5-2：我的推荐"><a href="#5-2：我的推荐" class="headerlink" title="5.2：我的推荐"></a>5.2：我的推荐</h2><p>前面的方式是 Homebrew 的推荐方式，除此之外，我们还可以按照自己习惯的方式来配置环境变量！</p><p>打开终端，<font color=red>在用户目录下</font>找到（或新建）名为<code>.zprofile</code>的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .zprofile</span><br></pre></td></tr></table></figure><p>然后将下面的内容粘贴进去（假如文件中已经存在其他内容，就将下面的内容追加在文件的最后）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Setting PATH for Homebrew</span><br><span class="line">PATH=&quot;/opt/homebrew/bin:/opt/homebrew/sbin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><p>这种方式跟前面的方式一样，重启终端后查看 PATH 变量，发现同样会：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150744449.png"></p><h1 id="第六节：检测结果"><a href="#第六节：检测结果" class="headerlink" title="第六节：检测结果"></a>第六节：检测结果</h1><p>经过上面的三步操作以后，按道理讲 Homebrew 就安装完成了，重新打开终端，直接执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --version</span><br></pre></td></tr></table></figure><p>假如此时能正确输出 Homebrew 的版本号，就表示安装和配置成功了： </p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150843552.png"></p><h1 id="第七节：使用细节"><a href="#第七节：使用细节" class="headerlink" title="第七节：使用细节"></a>第七节：使用细节</h1><p><font color=red>友情提示：以下内容是 2023-10-21 日更新！</font></p><p>这一节的主要内容是分析 Homebrew 的使用细节，比如使用<code>brew install 软件包</code>来安装软件时，软件被安装到了系统的什么位置，以及创建了什么样的软连接，再比如使用<code>brew uninstall 软件包</code>来卸载软件时的细节！</p><h2 id="7-1：软件安装"><a href="#7-1：软件安装" class="headerlink" title="7.1：软件安装"></a>7.1：软件安装</h2><p>在 Homebrew 的官网上有这么一段描述：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021151236600.png"></p><p>也就是说，Homebrew 会将软件安装到“独立目录”，通过配图可知，所谓的独立目录就是<code>/opt/homebrew/Cellar</code>！</p><p>我们可以做一个实验！打开终端，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tree</span><br></pre></td></tr></table></figure><p>执行的情况为：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021151526811.png"></p><p>通过比对系统前后的文件，发现安装命令做了如下两件事。</p><p>第一：软件包被安装到<code>/opt/homebrew/Cella</code>目录中了（这个目录原本是空的）；</p><p>第二：在<code>/opt/homebrew/bin</code>下面创建了一个名为<code>tree</code>的软连接，链接至安装的软件包中的真实命令</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021151712919.png"></p><p><font color=red>也就是说：使用 Homebrew 安装软件时，只会影响 Homebrew 自己的安装目录，不会影响到系统中其他任何目录！</font>正是因为我们在配置 Homebrew 时将目录<code>/opt/homebrew/bin</code>配置到系统的 PATH 环境变量中了，所以此时我们就可以使用其中安装的命令了！</p><p><font color=red>特别注意</font>：假如使用 Homebrew 安装系统中<code>/usr/bin</code>中原本就存在的命令时，会覆盖原本的命令，不是说修改了原本命令的链接，而是因为 Homebrew 在系统环境变量 PATH 中的位置<code>/opt/homebrew/bin</code>在<code>/usr/bin</code>之前！同时，因为它也在<code>/usr/local/bin</code>前面，也会覆盖 Nodejs 安装的命令！！！</p><h2 id="7-2：软件卸载"><a href="#7-2：软件卸载" class="headerlink" title="7.2：软件卸载"></a>7.2：软件卸载</h2><p>使用命令<code>brew uninstall 软件包</code>来卸载软件的时候，就会将安装软件时做的那两件事“复原”，这里就不赘述了！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果芯片的macOS安装Git</title>
      <link href="/post/10007.html"/>
      <url>/post/10007.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><p>对于开发人员而言，肯定都使用过 Git，而且基本上每天都在使用，但是在 Windows 和 macOS 上安装 Git 是不同的：</p><ul><li><p>在 Windows 平台上安装很简单，只需要下载下来安装程序，进行傻瓜式安装就可以了。需要主要的是：因为 Git 的官网是国外的网站，直接从官网上下载的话，经常会因为网络问题而失败，常用的解决方式就是借助淘宝的 NPM 镜像站来下载。</p><p>友情提示：从 2022 年 05 月 31 日开始，淘宝 npm 镜像源的域名更改为：<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></p></li><li><p>在 macOS 平台上，安装 Git 有很多种方式，比如使用 Command Line Tools 或 Homebrew，虽然安装的方式有很多种，但是相对而言较简单。</p></li></ul><p>这篇博文的主要内容就是介绍如何在 macOS 平台上安装配置 Git，并且解释一些 Git 的配置原理！</p><h1 id="第二节：安装-Git"><a href="#第二节：安装-Git" class="headerlink" title="第二节：安装 Git"></a>第二节：安装 Git</h1><p>在 macOS 上安装 Git，不管是 Intel 芯片还是苹果芯片的电脑，最简单的方式就是通过安装命令行工具（Command Line Tools）！<font color='red'>实际上，命令行工具中内置 Git，根本不需要自己再去下载安装 Git，这也是我推荐的方式！</font></p><p>关于如何给 macOS 安装命令行工具，以及安装命令行工具后系统的变化，都不是这篇博文的重点，在这里就不赘述了！</p><p>在安装命令行工具之前，假如你还没安装 Git 的话，这个时候执行命令<code>git --version</code>，可见系统中找不到 Git：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143147454.png"></p><p>刚安装完命令行工具后，再执行该命令后可见：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143259395.png"></p><p>顺便提一句，在没安装命令行工具之前，系统的<code>/usr/bin/</code>目录下就已经有名为<code>git</code>的可执行文件：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143308310.png"></p><p><font color='red'>安装完命令行工具后，这里的可执行文件就自动指向了其中安装的 Git</font>。跟 python3 一样，即使不安装命令行工具，该目录下也有这个命令，只是在安装完以后，<code>/usr/bin/python3</code>就会自动指向命令行工具中内置的 python 环境，并且从文件上来看并没有生成链接，这是 macOS 和 CLT 本身的处理，没必要关注！</p><h1 id="第三节：配置-Git"><a href="#第三节：配置-Git" class="headerlink" title="第三节：配置 Git"></a>第三节：配置 Git</h1><p><font color=red><strong>先验知识：Git 的所有配置是以文件的形式存储的！</strong></font></p><h2 id="3-1：Git的配置原理"><a href="#3-1：Git的配置原理" class="headerlink" title="3.1：Git的配置原理"></a>3.1：Git的配置原理</h2><p>Git 的配置分为系统级别、全局级别、项目级别这三个等级：</p><table><thead><tr><th align="center">权重</th><th align="center">中文名</th><th align="center">优先级</th><th align="center">配置文件</th></tr></thead><tbody><tr><td align="center">system</td><td align="center">系统级别</td><td align="center">低</td><td align="center"><code>etc/gitconfig</code></td></tr><tr><td align="center">global</td><td align="center">全局级别</td><td align="center">中</td><td align="center"><code>~/.gitconfig</code></td></tr><tr><td align="center">local</td><td align="center">仓库级别</td><td align="center">高</td><td align="center"><code>.git/config</code></td></tr></tbody></table><p>这三层配置具有不同的优先级，假如在这三个配置文件中定义的值有冲突的话，以优先级高的为准。比如在仓库级别和全局级别中都配置了用户名和邮箱，那么仓库级别的配置将发挥作用！</p><p><font color='red'><strong>Git 的配置文件</strong></font></p><ul><li>系统配置：配置文件一般是<code>/etc/gitcongif</code>，但假如使用的是CLT中内置的Git的话，配置文件是在CLT的安装目录中，具体位置是<code>/Library/Developer/CommandLineTools/usr/share/git-core/gitconfig</code>！</li><li>全局配置：配置文件是<code>~/.gitconfig</code>。默认该文件不存在，除非使用安装程序进行安装并在安装过程中进行全局配置时，才会生成这个文件；如果不是的话，这个文件只有在你第一次进行全局配置时才会自动生成！</li><li>项目配置：配置文件就是项目目录下的<code>.git/config</code>文件。这个文件不会发生变化，不管你是在什么平台上使用什么版本的 Git，项目级别的配置文件都不会发生变化！</li></ul><p><font color='red'><strong>查看 Git 的配置</strong></font></p><p>除了通过上面提到的三个配置文件来查看 Git 的配置以外，还可以使用<code>git config --list</code>来查看。比如我刚安装完命令行工具后、进行全局配置之前，查看 Git 的配置：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143655398.png"></p><h2 id="3-2：配置环境变量"><a href="#3-2：配置环境变量" class="headerlink" title="3.2：配置环境变量"></a>3.2：配置环境变量</h2><p>终端中执<code>git --version</code>命令可以直接输出 Git 版本号，使用<code>which</code>命令可见 Git 的命令是在<code>/usr/bin</code>目录下的，而这个目录本来就在 macOS 的 PATH 环境变量中：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143836079.png"></p><p>这两点都说明：<font color='red'><strong>使用命令行工具内置的 Git，我们不需要再单独配置环境变量</strong></font>！</p><h2 id="3-3：用户名和邮箱"><a href="#3-3：用户名和邮箱" class="headerlink" title="3.3：用户名和邮箱"></a>3.3：用户名和邮箱</h2><p>对于 Git 而言，用户名和邮箱地址这两条配置很重要，每次使用 Git 提交时都会引用这两条信息，用来说明是谁提交了内容更新，所以会随更新内容一起被永久纳入历史记录！而用户名和邮箱是用户可以任意自定义的，Git 在系统配置中不可能预先设置这两个配置，<font color='red'>所以在使用 Git 之前</font>，<font color='red'>配置用户名和邮箱就是必要的操作</font>！</p><p>Git 允许你设置一个全局的用户名和邮箱，同时也允许你为每个项目设置单独的用户名和邮箱。为了方便使用，我们一般会配置一个全局的，如果有需要的话，再在项目级别配置特殊的用户名和邮箱。</p><p>配置全局用户名和邮箱，使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br><span class="line">git config --global user.email 邮箱地址</span><br></pre></td></tr></table></figure><p>比如我在配置用户名和邮箱时是这样的：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020144159787.png"></p><p>执行了全局配置以后，在用户目录下就会生成<code>.gitconfig</code>的配置文件，文件内容为：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020144359565.png"></p><p>此时再通过<code>git config --list</code>命令来查看 Git 的配置：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020145010110.png"></p><p>假如要修改用户名和邮箱配置的话，只需要修改全局配置文件的内容即可，当然也可以通过<code>config</code>命令重新设置！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果芯片的macOS安装命令行工具</title>
      <link href="/post/10006.html"/>
      <url>/post/10006.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><h2 id="1-1：什么是命令行工具"><a href="#1-1：什么是命令行工具" class="headerlink" title="1.1：什么是命令行工具"></a>1.1：什么是命令行工具</h2><p>命令行工具（Command Line Tools）是 macOS 上至关重要的插件，苹果官方是这么介绍它的：下载 macOS SDK、标题和构建工具（如 Apple LLVM 编译器和 Make），能助您轻松安装开源软件或在终端内的 UNIX 上进行开发。macOS 可以在您首次尝试构建软件时自动下载这些工具，您也可以随时在下载页面找到它们。</p><p>简单地说，命令行工具有两个用处：</p><ul><li><font color='red'>使用Mac电脑终端开发软件</font>；</li><li><font color='red'>让开源软件能够顺利安装</font>；</li></ul><p>简单来说，Command Line Tools 就是一个小型独立包，为 macOS 终端用户提供了很多常用的工具、实用程序和一些编译器，包括但不限于 svn、git、make、gcc、clang、perl、size、strip、cpp、python3…</p><p>在使用 Mac 终端进行开发的时候，需要用到比如 Git 之类的工具！在 macOS 系统中原本就存在一些命令，也就是可执行文件，在<code>/usr/bin</code>目录下的那些常用命令，如 git 和 python3 等，这些命令虽然原本就存在，但是并不能使用！如：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020135808310.png"></p><p>再比如：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020135927169.png"></p><p>这些命令本身就存在，但是在使用的时候，Mac 终端会给出如下提示（此图已经更新过）：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020135947454.png"></p><p>这些工具会在我们安装完命令行开发者工具以后，就能正常使用了！</p><h2 id="1-2：我的-macOS-版本"><a href="#1-2：我的-macOS-版本" class="headerlink" title="1.2：我的 macOS 版本"></a>1.2：我的 macOS 版本</h2><p>我这里安装命令行工具的 macOS 版本是 macOS Sonoma 14.0 版！</p><h1 id="第二节：安装配置"><a href="#第二节：安装配置" class="headerlink" title="第二节：安装配置"></a>第二节：安装配置</h1><p>下载安装 Command Line Tools 有两种方式：</p><ul><li>第一种是去 Apple 开发者网站上去下载，下载之前需要先免费注册成为 Apple 开发者，然后再登陆下载；</li><li>第二种方式就比较简单了，可以通过 Mac 自带的终端，执行命令来安装（国内可能会因为网络问题而失败）；</li></ul><h2 id="2-1：下载安装"><a href="#2-1：下载安装" class="headerlink" title="2.1：下载安装"></a>2.1：下载安装</h2><p>这里我选择使用第二种方式。打开终端，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>按下回车键的时候，终端会给出提示：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140409917.png"></p><p>点击安装，又会弹出协议，点击“同意”：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140557483.png"></p><p>然后会自动查找软件：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140734927.png"></p><p>查找到以后，就自动下载了：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140805381.png"></p><p>刚开始展示的下载时间很长，但是网络好的话，很快就展示真实的下载时长了：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140924113.png"></p><p>下载完成后会自动安装：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020141134095.png"></p><p>待安装完成后，点击“完成”即可：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020141405504.png"></p><h2 id="2-2：安装位置"><a href="#2-2：安装位置" class="headerlink" title="2.2：安装位置"></a>2.2：安装位置</h2><p>原本在<code>/Library</code>目录下，以<code>D</code>开头的目录只有<code>DirectoryServices</code>、<code>Documentation</code>、<code>DriverExtensions</code>！</p><p>安装完以后，就会在<code>/Library</code>下生成名为<code>/Developer/CommandLineTools</code>的目录，目录中的内容如下：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142024664.png"></p><p>这些都是新生成的目录，其中三个子文件夹：</p><ul><li><code>Library</code>：安装的依赖库，我这里只能看到 python 的依赖库；</li><li><code>SDKs</code>：Apple APP 开发依赖的开发环境；</li><li><code>usr</code>：这个文件夹的内容是很多的，在它里面有很多的命令和依赖等，主要是 gcc、pip3、git 等等；</li></ul><p>注意：在这里的<code>/CommandLineTools/Library/Frameworks/Python3.framework/Versions</code>中安装了 python3 ！</p><h2 id="2-3：环境变量"><a href="#2-3：环境变量" class="headerlink" title="2.3：环境变量"></a>2.3：环境变量</h2><p>在没安装命令行工具之前，macOS 的环境变量为(此图已经更新)：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142129128.png"></p><p>而安装完以后，macOS的环境变量为：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142306822.png"></p><p>可见此时系统环境变量实际上并没有什么变化！而且此时可以直接使用<code>/usr/bin</code>目录下的命令，而不用配置环境变量！</p><h2 id="2-4：个人思考"><a href="#2-4：个人思考" class="headerlink" title="2.4：个人思考"></a>2.4：个人思考</h2><p>安装完命令行开发工具以后，我们在终端中就能使用这些命令了：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142434564.png"></p><p>首先，我们先来看一下在终端中使用的这些命令来自哪里：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142515905.png"></p><p>查看安装命令行工具前后 macOS 的 PATH 变量和指定文件，发现没有任何变化！最重要的是，查看命令行开发者工具目录中的这些命令，他们也没有指向<code>/usr/bin/</code>目录中的那些命令；同时<code>/usr/bin</code>中那些系统原本就存在但是无法使用的命令也没指向 CLT 中安装的命令！那就很奇怪了，为什么在<code>/Library/Developer/CommandLineTools/</code>中安装的这些命令可以被终端找到并使用呢？？？</p><p>其实这里就没必要关注这个问题了，即然 Mac 在<code>/usr/bin</code>目录中预留了<code>python3</code>和<code>pip3</code>等命令（虽然不能默认是不能使用的），而且命令行开发者工具又是为 macOS 量身定做，那么他们肯定在我们不得知的地方进行了特殊的处理，所以它就把<code>/Library/Developer/CommandLineTools/</code>目录中安装的这些命令都映射到了<code>/usr/bin</code>目录中原本存在的这些命令上了！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Command Line Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果芯片的macOS安装配置VSCode</title>
      <link href="/post/10005.html"/>
      <url>/post/10005.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：下载和安装"><a href="#第一节：下载和安装" class="headerlink" title="第一节：下载和安装"></a>第一节：下载和安装</h1><p>浏览器访问 VSCode 的<a href="https://code.visualstudio.com/">官网</a>，点击页面的下载链接：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020125527693.png"></p><p>下载下来的是一个<code>.app</code>格式的安装程序：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020125800526.png"></p><p>最后直接将这个文件拖动到应用程序文件夹中即可完成安装，之后从启动台来启动VSCode即可！</p><h1 id="第二节：自定义设置"><a href="#第二节：自定义设置" class="headerlink" title="第二节：自定义设置"></a>第二节：自定义设置</h1><h2 id="2-1：语言设置"><a href="#2-1：语言设置" class="headerlink" title="2.1：语言设置"></a>2.1：语言设置</h2><p>刚启动 VSCode 时，右下角会提示是否要切换到简体中文，点击“安装并重启”，稍等片刻即可切换语言为简体中文！</p><h2 id="2-2：用户登录"><a href="#2-2：用户登录" class="headerlink" title="2.2：用户登录"></a>2.2：用户登录</h2><p>VSCode 支持用户登陆，登陆用户可以同步自己的个性化设置，所以在设置之前最好登陆一下，然后以后每次重新安装的时候就不用重复设置了，只需要登陆即可。</p><p>点击左下角的头像按钮，选择“备份和同步设置…”，然后点击顶部的<code>登陆</code>：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020130801735.png"></p><p>最后选择使用 Github 账号或者 Microsoft 账号登陆都可以，在弹出的网页上输入账号和密码并点击登陆，当展示：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131231669.png"></p><p>则表示登陆成功，此时右下角会展示：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131327709.png"></p><h2 id="2-3：受信任区"><a href="#2-3：受信任区" class="headerlink" title="2.3：受信任区"></a>2.3：受信任区</h2><p>在 VSCode 中有“受信任区”这么个说法，所谓受信任区，简单理解就是 VSCode 可以访问和编辑的文件目录，假如使用 VSCode 打开非信任区的文件时，总是会给出提示：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131517298.png"></p><p>我们需要将本机所有的目录都放到信任区中，这样以后使用 VSCode 打开任意位置的文件时，就不会有警告了！</p><p>点击左下角的盾牌图标，接着点击<code>添加文件夹</code>：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131609871.png"></p><p>然后把本机根目录<code>/</code>添加进去：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131715183.png"></p><p>然后直接关闭这个页面，即可完成设置！</p><h2 id="2-4：字体相关"><a href="#2-4：字体相关" class="headerlink" title="2.4：字体相关"></a>2.4：字体相关</h2><p>VSCode 的字体有两种，一是页面 UI 字体，二是编辑区的字体！我们可以通过<code>command</code>和<code>-</code>或<code>+</code>来调整界面 UI 字体大小，而对于编辑区的默认字体，需要打开设置，依次选择“文本编辑器” –&gt; “字体”：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020132806018.png"></p><p>还可以通过 Ctrl 和鼠标滚轮的组合来灵活修改编辑区字体。在设置页面搜索“Mouse Wheel Zoom”：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020132922757.png"></p><h2 id="2-5：Tab-Size"><a href="#2-5：Tab-Size" class="headerlink" title="2.5：Tab Size"></a>2.5：Tab Size</h2><p>在文本编辑器中，尤其是使用 VSCode 编辑代码时，我们一般会使用 Tab 键来执行缩进操作。但是 Tab 键有时候虽然看起来是缩进了 4 个空格，但是它在编码上并不代表 4 个空格。所以这里我们设置一下，设置后的效果就是：每当键入 Tab 时，都能不多不少地正确输入 4 个空格（但是假如你经常使用 VSCode 来编辑前段代码，那最好是设置为 2 个空格）！</p><p>第一步：设置一个制表符代表的空格数是 2。打开设置，搜索“Tab Size”，将一个制表符等于的空格数设置为 2：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133228428.png"></p><p>第二步：关闭“Detect Indentation”。假如不关闭的话，VSCode 会根据文件内容自动推测 Tab 的空格数：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133412652.png"></p><h2 id="2-6：控制字符"><a href="#2-6：控制字符" class="headerlink" title="2.6：控制字符"></a>2.6：控制字符</h2><p>VSCode 的编辑页面默认会隐藏空格等字符（其他编辑器基本也是这样），但我使用它主要是用来看代码的，所以我希望可以在编辑区展示包括空格在内的所有字符！</p><p>第一步：打开设置后搜索“Render Control Characters”，进行如下设置</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133555571.png"></p><p>第二步：搜索“Render Whitespace”，将这一项的默认值由 selection 设置为 all</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133756686.png"></p><h1 id="第三节：个性化插件"><a href="#第三节：个性化插件" class="headerlink" title="第三节：个性化插件"></a>第三节：个性化插件</h1><h2 id="3-1：文件图标"><a href="#3-1：文件图标" class="headerlink" title="3.1：文件图标"></a>3.1：文件图标</h2><p>当使用 VSCode 打开文件夹时，上级目录展示的图标都是箭头：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133805147.png"></p><p>我们可以安装插件，让文件的图标更形象化，我使用的插件是<code>vscode-icons-mac</code>。打开插件市场搜索它：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133947951.png"></p><p>点击安装，安装完成以后，可见效果：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020134043705.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>留言板</title>
      <link href="/comment/index.html"/>
      <url>/comment/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>优秀链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图片展</title>
      <link href="/images/index.html"/>
      <url>/images/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐汇</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影院</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
  
</search>
