<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Github + Vercel 搭建免费的个人图床</title>
      <link href="/post/23.html"/>
      <url>/post/23.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><h2 id="1-1：各种图床"><a href="#1-1：各种图床" class="headerlink" title="1.1：各种图床"></a>1.1：各种图床</h2><p>经常使用 Markdown 进行文章创作的人，肯定对“图床”这个概念不陌生，拥有个人图床则更是一个刚需！现在市面上的图床产品非常多，有免费的也有收费的，也有一些是“限量免费”的。</p><p>其中收费的有腾讯云和阿里云等云服务商提供的对象存储服务，基本是按流量收费的，费用很低，如果你不想折腾，又不差这点钱，我还是强烈建议使用大厂的对象存储！它们能兼顾稳定性和存取速度！（<font color=red>友情提示</font>：假如你使用这种按流量收费的图床服务并将其中的图片放到自己的网站上的话，一定要处理好安全配置，并配合 CDN 来使用，否则一旦你的网站被攻击恶意刷流量的话，那么可能一觉起来你就欠费上千块了！）</p><p>以七牛云为代表的图床也是不错的，但免费的图床一般都会有空间限制，比如你只有500MB的免费空间，当你图片超过这个免费额度后，就得购买新的空间了。此外，免费的图床还有一个致命的缺点，就是稳定性差！所谓稳定性差，就是有可能会倒闭或者跑路！试想以下，你辛辛苦苦攒的图片，因为图床供应商倒闭了或者跑路了，你的所有图片都会化为泡影！</p><p>免费的和收费的图床各有优劣，我就不再赘述了，我这篇博文主要是用来记录如何使用 Github 来搭建一个免费的图床！</p><h2 id="1-2：Github"><a href="#1-2：Github" class="headerlink" title="1.2：Github"></a>1.2：Github</h2><p>对于免费的图床，我选择的是 Github，使用 Github 搭建图床具备以下优势：</p><ul><li>很稳定，不会跑路，作为全球最大的代码托管平台，这一点毋庸置疑；</li><li>使用自己的仓库来存储图片，图片可以增量快速更新，跨设备管理；</li><li>因为使用 Git 进行上传和下载，可以进行版本管理和查看之前的版本；</li></ul><p>当然，Github 图床也有一些显著的缺点：</p><ul><li>每个仓库限制 1 G，超过这个容量就要新建一个仓库；</li><li>在国内由于网络限制，访问速度很不理想，甚至不能访问，但配合免费公共的 CDN，读取速度还是相当不错的；</li><li>使用 Github 做图床，你就担上了滥用开源的罪名！（<del>当我没说，哈哈</del>）</li></ul><h2 id="1-3：我的选择"><a href="#1-3：我的选择" class="headerlink" title="1.3：我的选择"></a>1.3：我的选择</h2><p>总体而言，使用 Github 做图床还是很可取的，尤其是存放那些经常被访问的图片（毕竟是免费的啊）。比如，在我的博客网站中有很多图片，所有的图片主要分为两类：第一类是网站的背景图等公共图片；第二类是文章中的插图等非公共资源。前者被访问的频率显然要比后者更高，这也就意味着在我的博客网站中公共图片会产生更多的流量。所以，我采取如下策略：首先，将经常被访问的公共图片放在 Github 上，这样就不用为这部分流量付钱了；其次，将非公共图片放到腾讯云的对象存储 COS 中，因为非公共图片被访问的频率低，并且图片较多，可以集成 PicGo 来实现一键上传，重要的是使用对象存储可以显著提供文件的加载速度，省去了配置 CDN 的麻烦。</p><p><font color=red>特别提示</font>：无论你将自己的图片托管在哪个平台上，都应该做好备份，因为只要是第三方的服务，都有可能因为各种各样的原因而失去，谁也不能保证万无一失！</p><h1 id="第二节：具体配置"><a href="#第二节：具体配置" class="headerlink" title="第二节：具体配置"></a>第二节：具体配置</h1><h2 id="2-1：创建仓库"><a href="#2-1：创建仓库" class="headerlink" title="2.1：创建仓库"></a>2.1：创建仓库</h2><p>登录 Github 官网，假如你还没有账号则需要注册一个，然后创建一个仓库，比如我创建的图床仓库：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021205430860.png"></p><p>点击最后的<code>Create repository</code>后，就创建了一个仓库：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021205644236.png"></p><h2 id="2-2：克隆仓库"><a href="#2-2：克隆仓库" class="headerlink" title="2.2：克隆仓库"></a>2.2：克隆仓库</h2><p>在你计算机本地找一个目录，将 Github 上创建的图床仓库克隆下来，比如我将其放在我桌面的<code>repository</code>文件中：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021205919665.png"></p><p>然后本地仓库就生成了：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021211146191.png"></p><h2 id="2-4：上传图片"><a href="#2-4：上传图片" class="headerlink" title="2.4：上传图片"></a>2.4：上传图片</h2><p>此时就可以使用 Git 往这个仓库中推送图片了，但为了方便图片的管理，一般我们会在仓库中创建子目录。比如我先创建了一个名为<code>avatars</code>的文件夹，然后在其中放入了一张名为<code>boy.png</code>的图片（顺便创建<code>.gitignore</code>文件）：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021211333758.png"></p><p><font color=red><strong>友情注意</strong></font>：此时就可以将本地仓库推送到 Github 仓库了！但是第一次提交代码的时候，需要验证用户名和密码，这里用户名输入 Github 的用户名，<font color=red>但密码则不是你的登录密码，而是你仓库的口令——token</font>！因为从 2021 年 8 月 13 日开始，Github 就不再接受密码验证了，转而接受 token！所以为了建立你的计算机和 Github 仓库的通信，你首先需要创建一个口令（假如你不知道如何创建口令，可以参考我的这篇博文<a href="https://www.fattymonkey.com/post/11.html">《Github使用口令替代密码来进行上传验证》</a>）！</p><p>上传成功以后，可以在 Github 仓库看到上传的资源：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021211801431.png"></p><h2 id="2-5：访问图片"><a href="#2-5：访问图片" class="headerlink" title="2.5：访问图片"></a>2.5：访问图片</h2><p>将图片上传到 Github 仓库后，我们怎么样访问仓库中的图片呢？使用如下两种路径：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/用户名/仓库名/blob/分支名/图片在仓库中的绝对路径?raw=true</span><br><span class="line">https://github.com/用户名/仓库名/raw/分支名/图片在仓库中的绝对路径</span><br></pre></td></tr></table></figure><p>比如访问仓库中位于<code>avatars</code>文件夹中的名为<code>boy.png</code>的图片，那么它的路径就是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/fattymonkey/blog-source/blob/main/avatars/boy.png?raw=true</span><br><span class="line">https://github.com/fattymonkey/blog-source/raw/main/avatars/boy.png</span><br></pre></td></tr></table></figure><h1 id="第三节：配置加速"><a href="#第三节：配置加速" class="headerlink" title="第三节：配置加速"></a>第三节：配置加速</h1><p>将图片上传到 Github 仓库以后，通过使用 Github 给我们的图片路径，就可以访问图片了。但此时还存在一个很严重的问题，就是网络问题。Github 是国外的网站，由于我们国内的网络限制，访问速度很慢，大多数时候甚至根本访问不了！为了解决这个问题，我们就必须为 Github 使用 CDN 加速！目前推荐的 CDN 加速有以下三种。</p><h2 id="3-1：Statically"><a href="#3-1：Statically" class="headerlink" title="3.1：Statically"></a>3.1：Statically</h2><p>很多人都知道 Jsdelivr，开发者们经常会用它来加速 CSS 或 JS 之类的静态资源，当然也会有部分哥们用它来加速图像服务（但在这里建议适量使用，滥用不是一个好的思想）。</p><p>Statically 也是一款为开发者免费提供的 CDN 加速服务，它与 Jsdelivr 一样有着深厚的资源支持，同时其支持的内容更加丰富一些。并且它目前是免费的，速度也是相当不错（且用且珍惜吧）。</p><h3 id="3-1-1：配置"><a href="#3-1-1：配置" class="headerlink" title="3.1.1：配置"></a>3.1.1：配置</h3><p>Statically 压根就不用配置，只需要在访问图片时，修改访问图片的 URL 路径即可。</p><h3 id="3-1-2：使用"><a href="#3-1-2：使用" class="headerlink" title="3.1.2：使用"></a>3.1.2：使用</h3><p>比如 Github 提供给我们的图片链接是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">https://github.com/用户名/仓库名/blob/分支名/图片在仓库中的绝对路径?raw=true</span><br><span class="line">https://github.com/用户名/仓库名/raw/分支名/图片在仓库中的绝对路径</span><br></pre></td></tr></table></figure><p>我们只需要将其修改为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://cdn.staticaly.com/gh/用户名/仓库名@分支名/图片在仓库中的绝对路径</span><br></pre></td></tr></table></figure><p>这样就可以访问了，简单且高效！</p><h2 id="3-2：Vercel"><a href="#3-2：Vercel" class="headerlink" title="3.2：Vercel"></a>3.2：Vercel</h2><p>Vercel 现在非常火爆，Vercel 类似 Github Pages，但远比 Github Pages 强大，速度也快得多，而且将 Github 授权给 Vercel 后，可以得到最优雅的发布体验只需要将代码推送，项目就自动更新部署了！Vercel 还支持 serverless 接口，这就意味着它不仅可以部署静态网站，还可以部署动态网站，而这些功能通通都是免费的，简直就是白嫖党的福利！Vercel 还支持 https ，不用自己去 FreeSSL 申请证书，更是省去了一大堆的证书配置，简直就是懒人的福利！</p><p>使用 Vercel 来部署我们的图床仓库，能极大的提升访问速度，因为它提供了全局的 CDN 加速！但是现在 Vercel 的域被墙了，需要绑定一个自己的域名才能在国内访问，并且有每个月 100 G 的流量限制（问题不大，我觉得完全够用）。</p><h3 id="3-2-1：注册账号"><a href="#3-2-1：注册账号" class="headerlink" title="3.2.1：注册账号"></a>3.2.1：注册账号</h3><p>访问 Vercel <a href="https://vercel.com/">官网</a>，建议选择使用 Github 账号来注册。<font color=red><strong>注意</strong></font>：大多数情况下我们的 Github 账号是用国内的邮箱注册的，但是 Vercel 在验证 Github 账号的时候会校验它的主邮箱，假如你 Github 的主邮箱是国内邮箱的话，就会注册失败！一旦你注册失败，就会出现下面的情况：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212119857.png"></p><p>建议<font color=red>在注册 Vercel 之前就把你 Github 的主邮箱修改为国外的邮箱</font>，如果你已经使用了国内的邮箱注册了 Github，那么：</p><ol><li><p>注册一个谷歌邮箱，国内访问<code>Gmail</code>的方案：</p><ul><li><p>直接使用 QQ 邮箱手机版，它提供 <code>Gmail</code> 的访问路线，可以直接注册并使用；</p></li><li><p>使用 <code>Ghelper</code> 等浏览器插件访问。详情可以参考这篇文章：<a href="https://github.com/Zfour/python_github_calendar_api/blob/master/posts/8c8df126">玩转 Microsoft-Edge</a></p></li></ul></li><li><p>将注册的谷歌邮箱设置为 Github 的主邮箱</p><ul><li><p><code>头像</code> &gt; <code>Settings</code> &gt; <code>Emails</code>，然后添加注册的谷歌邮箱，然后验证添加的邮箱；</p></li><li><p>最后在<code>Primary email address</code>下方选择前面添加的谷歌邮箱；</p></li></ul></li><li><p>访问Vercel官网，使用谷歌邮箱进行注册，注册的时候需要验证手机号，国内手机号也可以，完成注册</p></li></ol><h3 id="3-2-2：部署仓库"><a href="#3-2-2：部署仓库" class="headerlink" title="3.2.2：部署仓库"></a>3.2.2：部署仓库</h3><p>进入 Vercel 控制面板，点击页面的“Create a New Project”，在“Import Git Repository”处选择前面创建的仓库：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212501911.png"></p><p>然后点击对应仓库的“Import”按钮，然后直接点击“Deploy”按钮来部署：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212641548.png"></p><p>稍等片刻，就能看到部署项目成功的提示（Congratulations）：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021212815121.png"></p><p><font color=red>友情提示</font>：此时可见左边的项目页面报错 404，这是因为我们仓库的根目录下没有名为<code>index.html</code>的文件，我们可以在仓库根目录下创建这个文件，就能消除这个警告！比如我在仓库根目录下创建了这个文件，并编辑它的内容如下</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">HTML</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>我的博客资源<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;color:red;text-align: center;&quot;</span>&gt;</span>博客资源仓库部署成功<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>上传到仓库后，点击右上角的“Continue to Dashboard”，进入项目控制台，可见效果：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021213244947.png"></p><h3 id="3-2-3：绑定域名"><a href="#3-2-3：绑定域名" class="headerlink" title="3.2.3：绑定域名"></a>3.2.3：绑定域名</h3><p>Vercel 给我们分配了一个域名，也就是上图中的<code>blog-source-two.vercel.app</code>，原本我们可以使用这个域名来访问我们的仓库，但由于现<code>.app</code>这个域被墙了，所以我们需要配置一个自己的域名才能访问！</p><p>点击右上方的“Domains”，添加一个自己的域名：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021213457561.png"></p><p>然后点击“Add”，此时发现添加的域名是无效的：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021213951367.png"></p><h3 id="3-2-4：配置解析"><a href="#3-2-4：配置解析" class="headerlink" title="3.2.4：配置解析"></a>3.2.4：配置解析</h3><p>然后去我们购买域名的域名解析处，配置上图中提示给我们的两条解析记录，比如我的情况是：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021215659785.png"></p><p>配置完等待 DNS 生效，然后 Vercel 还会自动配置 SSL 安装证书，最终：</p><p><img src="https://www.czblogs.cn/posts/tools/03/image-20231021215815108.png"></p><h3 id="3-2-5：具体使用"><a href="#3-2-5：具体使用" class="headerlink" title="3.2.5：具体使用"></a>3.2.5：具体使用</h3><p>现在，我们就可以使用自定义的域名来访问图片了！访问的 URL 是：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">自定义域名/图片的仓库路径</span><br></pre></td></tr></table></figure><p>比如图片在仓库中的路径是<code>/avatars/boy.png</code>，那么就可以在浏览器地址栏中使用下面这两个路径来访问图片：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">czblogs.cn/avatars/boy.png</span><br><span class="line">www.czblogs.cn/avatars/boy.png</span><br></pre></td></tr></table></figure><p><font color=red>注意</font>：在 Markdown 中要加上<code>https://</code>，因为 Markdown 不能像浏览器那样自动为 URL 添加这个前缀！</p><h2 id="3-3：CloudFlare"><a href="#3-3：CloudFlare" class="headerlink" title="3.3：CloudFlare"></a>3.3：CloudFlare</h2><p>cloudflare 的访问速度比 Vercel 的速度差一点，Vercel 是我目前使用的方式，暂时先不更新 cloudflare 的配置和使用！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
            <tag> CDN </tag>
            
            <tag> Vercel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>这篇文章或许能让你彻底了解Markdown</title>
      <link href="/post/12.html"/>
      <url>/post/12.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：基本概述"><a href="#第一节：基本概述" class="headerlink" title="第一节：基本概述"></a>第一节：基本概述</h1><h2 id="1-1：它是什么"><a href="#1-1：它是什么" class="headerlink" title="1.1：它是什么"></a>1.1：它是什么</h2><blockquote><p>Markdown 是一种轻量级的标记语言，可用于在纯文本文档中添加格式化元素，允许人们使用易读易写的纯文本格式编写文档。Markdown 由 John Gruber 于 2004 年创建，如今已成为世界上最受欢迎的标记语言之一。</p></blockquote><p>最开始的时候，人们使用记事本来编辑文档，但是后来发现纯文本文档真的太单调了！然后，Word 闪亮登场，从此 Word 就成为了编辑文本文档的主要工具，在 Word 中人们可以对任意的文字进行排版美化，比如设置各级标题以及文字的大小和颜色。Word 丰富多彩的文本样式，让它成为了主流的文本信息传播手段。但随着网络的发展，Word 文件过于笨重的缺点就暴露出来了，此时又诞生了 HTML，它可以使用轻量级的标记来实现文本文档的渲染，但是它的渲染功能依赖于解释环境（浏览器就是最常见的解释器），在信息传播的过程中没有那么随心所欲。</p><p>对于平时需要进行大量码字的人而言，显然笨重的 Word 和依赖浏览器的 HTML 都不符合他们的诉求。因此，诞生了 Markdown，它跟 HTML 语法一样，也是使用各种标记来实现文本样式的渲染，但是跟 HTML 相比，它更加轻量级，更加简单！在电脑系统中，Markdown 文本文件就是以<code>md</code>或<code>MD</code>为扩展名的文件！</p><p><font color=red>假如你对 HTML 有基本的了解，那么此时你就可以将 Markdown 理解为简化版的 HTML ！并且在 Markdown 文本中可以直接使用 HTML 元素而无需转译！</font></p><h2 id="1-2：使用场景"><a href="#1-2：使用场景" class="headerlink" title="1.2：使用场景"></a>1.2：使用场景</h2><p>由于 Markdown 轻量化、易读、易写的特性，并且对于图片、图表、数学公式等都有支援，目前许多网站都广泛使用它来撰写说明文档或是用于论坛上发表讯息，最常见的就是代码托管平台（比如国外的 Github 和国内的 Gitee）都采用 Markdown 语法来撰写 README 文件。当前，国内外比较知名的平台和大厂，也逐渐将 Markdown 作为文档标准！</p><p>此外，不管是学生、老师，亦或者是其他工作者，基本上有做笔记和码字需求的人，只要接触到 Markdown 以后，基本上都会被它的魅力折服，我们可以拿它来做笔记、演讲文稿、写博客……</p><h2 id="1-3：它的优势"><a href="#1-3：它的优势" class="headerlink" title="1.3：它的优势"></a>1.3：它的优势</h2><p>Markdown 有如下最明显的优势：</p><ol><li>语法简单，没有什么学习成本，能轻松在码字的同时做出美观大方的排版；</li><li>纯文本，易读易写，可以方便地纳入版本控制；</li><li>让使用者可以专注于文字内容本身；</li></ol><p>举个例子，假如你想在你的文档中编辑一个一级标题和一个二级标题，那么你只需要在 Markdown 文件中键入如下内容：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 这是标题一</span><br><span class="line">## 这是标题二</span><br></pre></td></tr></table></figure><p>这是一段<font color=red>纯文本</font>，当把它拿到 Markdown 解析器或可以直接解释 Markdown 的编辑器中，它就是下面这个样子：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204007063.png"></p><p>一个<code>#</code>加一个空格则表示标题一，两个<code>#</code>加一个空格则表示标题二，以此类推.. 因此在 Markdown 中要想键入各个等级的标题，仅仅使用<code>#</code>和空格就可以实现了！</p><p>此外，现在一些优秀的 Markdown 编辑器，将它的编辑和解释结合，实现了更加便捷的编辑和展示效果！其中以 Typora 为代表。 在 Typora 中，当你键入<code>Ctrl</code>+<code>1</code>的快捷键，就可以在光标所在那一行（自然行，包括自动折行）的内容前面添加一个<code>#</code>及空格，直接将其设为一级标题，并且能实现“所键即所得”（能直接渲染出 Markdown 的样式而不改变 Markdown 源码）！</p><h2 id="1-4：它的局限"><a href="#1-4：它的局限" class="headerlink" title="1.4：它的局限"></a>1.4：它的局限</h2><p>Markdown 是纯文本文件，所以其本身不能存储图片，只能存储图片的链接！Markdown 插入图片的语法是：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](图片路径)</span><br></pre></td></tr></table></figure><p>然后 Markdown 的编辑器在解析这段内容的时候，会自动将引用的图片放到这里，实现“图文并茂”！图片路径可以是相对路径或绝对路径，大多数情况下，我们在 Markdown 中插入图片时都是使用的相对路径，那么在传输文件的时候，若想要对方也能在该 Markdown 中看到我们插入的图片，就必须把图片也传过去，而且要求 Markdown 文件和图片所在的文件夹的相对位置不能改变，我认为这是 Markdown 目前最大的局限！</p><p><font color=red>PS</font>：我们可以使用图床来解决这个问题，但是图床不是我这篇博文的重点，故省略！</p><h1 id="第二节：基本语法"><a href="#第二节：基本语法" class="headerlink" title="第二节：基本语法"></a>第二节：基本语法</h1><p>Markdown 简洁的语法，号称半小时就可以掌握，学习成本很低，所有的语法在它的<a href="https://markdown.com.cn/intro.html">官网</a>或<a href="https://www.runoob.com/markdown/md-tutorial.html">菜鸟驿站</a>中学得，我这里记录了一些我常用的 Markdown 语法，虽不全面，但是够我个人使用了，方便以后我来查询。</p><p>PS：官网提供了在线 Markdown 编辑器，在左边输入 Markdown 文本，在右边能直接展示出相应的效果，<a href="https://markdown.com.cn/editor/">网址在这</a>！</p><h2 id="2-1：标题"><a href="#2-1：标题" class="headerlink" title="2.1：标题"></a>2.1：标题</h2><p>Markdown 提供了六级标题，第 n 级标题就使用连续的 n 个<code>#</code>加上一个空格，后面跟上标题文本</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># 标题一</span><br><span class="line">## 标题二</span><br><span class="line">### 标题三</span><br><span class="line">#### 标题四</span><br><span class="line">##### 标题五</span><br><span class="line">###### 标题六</span><br></pre></td></tr></table></figure><p>PS：原始的 Markdown 只有三级标题，后来扩展到六级标题（因为 Markdown 的理念就是简化文本编辑，更多级的标题有悖于这个理论，所以最多只有六级标题）。</p><h2 id="2-2：斜体"><a href="#2-2：斜体" class="headerlink" title="2.2：斜体"></a>2.2：斜体</h2><p>使用一对<code>*</code>包裹的文本，会被解析为斜体：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*要斜体的文本*</span><br></pre></td></tr></table></figure><h2 id="2-3：粗体"><a href="#2-3：粗体" class="headerlink" title="2.3：粗体"></a>2.3：粗体</h2><p>使用一对<code>**</code>包裹的文本，会被解析为加粗字体：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**要加粗的文本**</span><br></pre></td></tr></table></figure><h2 id="2-4：引用"><a href="#2-4：引用" class="headerlink" title="2.4：引用"></a>2.4：引用</h2><p>对于引用的文本，可以使用<code>&gt;</code>和一个空格引出：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 引用的文本</span><br></pre></td></tr></table></figure><h2 id="2-5：列表"><a href="#2-5：列表" class="headerlink" title="2.5：列表"></a>2.5：列表</h2><p>有序列表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. first item</span><br><span class="line">2. second item</span><br><span class="line">3. third item</span><br></pre></td></tr></table></figure><p>无序列表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- first item</span><br><span class="line">- second item</span><br><span class="line">- third item</span><br></pre></td></tr></table></figure><p>注意：<font color=red>数字或-跟后面的列表内容之间有且仅有一个空格！</font></p><h2 id="2-6：代码"><a href="#2-6：代码" class="headerlink" title="2.6：代码"></a>2.6：代码</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`code`</span><br></pre></td></tr></table></figure><p>PS：这里的符号是键盘 Tab 键上方的那个符号（英文输入模式）！</p><h2 id="2-7：链接"><a href="#2-7：链接" class="headerlink" title="2.7：链接"></a>2.7：链接</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[展示的文本](链接的地址)</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;链接的地址&gt;</span><br></pre></td></tr></table></figure><p>PS：后一种方式表示展示的文本和链接的地址相同！</p><h2 id="2-8：图片"><a href="#2-8：图片" class="headerlink" title="2.8：图片"></a>2.8：图片</h2><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![alt text](image.jpg)</span><br></pre></td></tr></table></figure><p>这里的地址可以是绝对路径或相对路径，也可以是网上任意可用的图片 URL！</p><h2 id="2-9：分隔线"><a href="#2-9：分隔线" class="headerlink" title="2.9：分隔线"></a>2.9：分隔线</h2><p>使用三个连续的<code>-</code>来表示分隔线：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">---</span><br></pre></td></tr></table></figure><h2 id="2-10：删除线"><a href="#2-10：删除线" class="headerlink" title="2.10：删除线"></a>2.10：删除线</h2><p>使用一对<code>~~</code>包裹的文本，会被添加删除线：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~~文本~~</span><br></pre></td></tr></table></figure><h2 id="2-11：内嵌HTML"><a href="#2-11：内嵌HTML" class="headerlink" title="2.11：内嵌HTML"></a>2.11：内嵌HTML</h2><p>对于Markdown涵盖范围之外的标签，都可以直接在文件里面用HTML本身。如需使用HTML，不需要额外标注这是HTML或是Markdown，只需HTML标签添加到Markdown文本中即可（反过来则不可以）。</p><p><font color=red><strong>第一类：行级标签</strong></font></p><p>HTML 的行级內联标签如 <code>&lt;span&gt;</code>和<code>&lt;cite&gt;</code>不受限制，可以在 Markdown 的段落、列表或是标题里任意使用。依照个人习惯，甚至可以不用 Markdown 格式，而采用 HTML 标签来格式化。例如：如果你比较喜欢 HTML 的 <code>&lt;a&gt;</code> 或 <code>&lt;img&gt;</code> 标签的话，可以直接使用这些标签，而不用 Markdown 提供的链接或是图片语法。当你需要更改元素的属性时（例如为文本指定颜色或更改图像的宽度），使用 HTML 标签更方便些。</p><p>HTML 行级內联标签和区块标签不同，在內联标签的范围内， Markdown 的语法是可以解析的。</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This **word** is bold. This &lt;em&gt;word&lt;/em&gt; is italic.</span><br></pre></td></tr></table></figure><p><font color=red><strong>第二类：块状标签</strong></font></p><p>区块元素──比如 <code>&lt;div&gt;</code>、<code>&lt;table&gt;</code>、<code>&lt;pre&gt;</code>、<code>&lt;p&gt;</code> 等标签，必须在前后加上空行，以便于内容区分。而且这些元素的开始与结尾标签，不可以用 tab 或是空白来缩进。Markdown 会自动识别这区块元素，避免在区块标签前后加上没有必要的 <code>&lt;p&gt;</code> 标签。</p><p>例如，在 Markdown 文件里加上一段 HTML 表格：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">This is a regular paragraph.</span><br><span class="line"></span><br><span class="line">&lt;table&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;Foo&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/table&gt;</span><br><span class="line"></span><br><span class="line">This is another regular paragraph.</span><br></pre></td></tr></table></figure><p><font color=red><strong>注意</strong></font>：Markdown语法在HTML区块标签中将不会被进行处理，也就是说，你不能在HTML块标签中使用Markdown语法！</p><h1 id="第三节：扩展语法"><a href="#第三节：扩展语法" class="headerlink" title="第三节：扩展语法"></a>第三节：扩展语法</h1><h2 id="3-1：表格"><a href="#3-1：表格" class="headerlink" title="3.1：表格"></a>3.1：表格</h2><p>要添加表格，请使用三个或多个连字符（<code>---</code>）创建每列的标题，并使用管道（<code>|</code>）分隔每列，可以选择在表的任一端添加管道：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description |</span><br><span class="line">| ----------- | ----------- |</span><br><span class="line">| Header      | Title       |</span><br><span class="line">| Paragraph   | Text        |</span><br></pre></td></tr></table></figure><p>显示如下：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204048531.png"></p><p>您可以通过在标题行中的连字符的左侧，右侧或两侧添加冒号（<code>:</code>），将列中的文本对齐到左侧，右侧或中心。比如</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| Syntax      | Description | Test Text     |</span><br><span class="line">| :---        |    :----:   |          ---: |</span><br><span class="line">| Header      | Title       | Here&#x27;s this   |</span><br><span class="line">| Paragraph   | Text        | And more      |</span><br></pre></td></tr></table></figure><p>显示如下：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204121309.png"></p><h2 id="3-2：脚注"><a href="#3-2：脚注" class="headerlink" title="3.2：脚注"></a>3.2：脚注</h2><p>脚注的使用频率很低，采用<code>[^数字]</code>用来表示脚注，比如在文本中使用<code>[^数字]</code>来添加一个标记：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Here&#x27;s a sentence with a footnote. [^1]</span><br></pre></td></tr></table></figure><p>然后就可以在页脚处来表明脚注来源了：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^1]: This is the footnote.</span><br></pre></td></tr></table></figure><h2 id="3-3：代码块"><a href="#3-3：代码块" class="headerlink" title="3.3：代码块"></a>3.3：代码块</h2><p>代码块使用如下的方式：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">```代码语言</span><br><span class="line">这是代码</span><br><span class="line">```</span><br></pre></td></tr></table></figure><p>比如一段Python代码：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">```python</span><br><span class="line">nums = &#123;1, 2, 3&#125;</span><br><span class="line">for i in nums:</span><br><span class="line">    print(i)</span><br><span class="line">```</span><br></pre></td></tr></table></figure><h2 id="3-4：定义列表"><a href="#3-4：定义列表" class="headerlink" title="3.4：定义列表"></a>3.4：定义列表</h2><p>除了前面的有序列表和无序列表以外，我们还可以自定义列表：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">First Term</span><br><span class="line">: This is the definition of the first term.</span><br><span class="line"></span><br><span class="line">Second Term</span><br><span class="line">: This is one definition of the second term.</span><br><span class="line">: This is another definition of the second term.</span><br></pre></td></tr></table></figure><p>类似于 HTML 中的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>First Term<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>This is the definition of the first term.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>Second Term<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>This is one definition of the second term. <span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dd</span>&gt;</span>This is another definition of the second term.<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="3-5：标题编号"><a href="#3-5：标题编号" class="headerlink" title="3.5：标题编号"></a>3.5：标题编号</h2><p>所谓标题编号，就是给标题自定义一个id选择器。比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">### 标题三 &#123;#custom-id&#125;</span><br></pre></td></tr></table></figure><p>相当于 HTML 中的：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">&quot;custom-id&quot;</span>&gt;</span>标题三<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样一来，其他网站中要想跳转到被编号的标题为止，可以在编号所在网页完整的 URL 后面添加<code>#custom-id</code>来链接！</p><h2 id="3-6：任务列表"><a href="#3-6：任务列表" class="headerlink" title="3.6：任务列表"></a>3.6：任务列表</h2><p>所谓任务列表，就是在一个普通列表的前面会有方括号，其中会有对号表示完成的内容，比如：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- [x] Write the press release</span><br><span class="line">- [ ] Update the website</span><br><span class="line">- [ ] Contact the media</span><br></pre></td></tr></table></figure><p>展示效果如下：</p><p><img src="https://www.czblogs.cn/posts/tools/02/image-20231021204150715.png"></p><p>~~</p><p>~~</p><p>~~</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Github使用口令替代密码来进行上传验证</title>
      <link href="/post/11.html"/>
      <url>/post/11.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：错误描述"><a href="#第一节：错误描述" class="headerlink" title="第一节：错误描述"></a>第一节：错误描述</h1><h2 id="1-1：报错信息"><a href="#1-1：报错信息" class="headerlink" title="1.1：报错信息"></a>1.1：报错信息</h2><p>假如你在 2021 年 8 月 13 日前后都往 Github 上提交过代码，那么在这个时间点以后，你肯定遇到过类似下面的错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">remote: Support for password authentication was removed on August 13, 2021.</span><br></pre></td></tr></table></figure><p>比如，我在 Github 上创建了一个新的仓库，并且用一台新的电脑第一次往这个仓库中提交代码，当提示我输入用户名和密码的时候，我照做了（且用户名和密码都输入正确），但是结果却报错：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021170548378.png"></p><h2 id="1-2：分析原因"><a href="#1-2：分析原因" class="headerlink" title="1.2：分析原因"></a>1.2：分析原因</h2><p>由报错信息可知，从 2021 年 8 月 13 日开始，Github 删除了对使用密码进行身份验证的支持！也就是说，之前你在提交代码时（第一次提交）使用 GitHub 的用户名和密码进行验证的方式已经不能使用了，用户名是指 Github 的用户名，密码则是 Github 的登录密码！</p><p>通过查阅官方文档，我发现 <font color=red>Github 现在提交代码时使用 token（口令）来替代登录密码来进行验证！</font>即使在提交代码时要求你输入的是“Password”，你依然应该输入 token 而不是 password！</p><h1 id="第二节：使用口令"><a href="#第二节：使用口令" class="headerlink" title="第二节：使用口令"></a>第二节：使用口令</h1><h2 id="2-1：创建口令"><a href="#2-1：创建口令" class="headerlink" title="2.1：创建口令"></a>2.1：创建口令</h2><p>点击 Github 主页头像，选择<code>Settings</code>，然后点击侧边栏的<code>&lt;&gt;Developer settings</code>，跳转到如下页面：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021170651466.png"></p><p>展开侧边栏的<code>Personal access token</code>，并点击<code>Token(classic)</code>：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021170914227.png"></p><p>跳转后，假如你还没有创建口令，依次点击<code>Generate new token</code> &gt; <code>Generate new token(classic)</code>：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171027238.png"></p><p>然后，对即将生成的口令进行初始化设置，比如我创建一个个人使用的永远不过期的口令：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171238531.png"></p><p>解释一下这里的设置：</p><ul><li>Note：任意填写，因为我们可能会创建很多口令，这个用来标记不同的口令，防止忘记；</li><li>Expiration：有效期，可选的有7天、30天、60天、90天、不限制，还可以自己定制时长；</li><li>Select scopes：选择范围，就是说你创建的这个口令具备的权限，勾选 repo 表示赋予仓库级别的权限；</li></ul><p>最后点击最下面的<code>Generate token</code>按钮，完成创建，页面自动生成口令：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171245030.png"></p><p>注意：口令生成以后记得保存下来，一旦离开这个页面再进来，就看不到之前生成的口令明文了</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171329123.png"></p><h2 id="2-2：使用口令"><a href="#2-2：使用口令" class="headerlink" title="2.2：使用口令"></a>2.2：使用口令</h2><p>使用口令很简单，只需要在推送代码时将其作为密码来使用即可：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021171514066.png"></p><p>一旦你使用了口令以后，口令会自动保存在你的计算机缓存文件中，下次再推送的时候就不需要重复输入了。比如在 Mac 中，使用了口令以后，就可以在钥匙串中找到：</p><p><img src="https://www.czblogs.cn/posts/tools/01/image-20231021172121473.png"></p><p>友情提示：从这里可以找到明文的口令，但是前提是你已经用口令提交过至少一次代码，所以在上面生成口令的时候一定要先复制保存起来！！！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 工具相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>M1安装python3的最佳实践</title>
      <link href="/post/10.html"/>
      <url>/post/10.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：先验知识"><a href="#第一节：先验知识" class="headerlink" title="第一节：先验知识"></a>第一节：先验知识</h1><h2 id="1-1：内置python环境"><a href="#1-1：内置python环境" class="headerlink" title="1.1：内置python环境"></a>1.1：内置python环境</h2><p>一直以来，macOS 系统都有内置 python 环境的，只不过内置的都是 python2，因此在老版本的 macOS 终端中可以直接运行 python！但是从 macOS12.3 开始，macOS 系统就移除了内置的 python！</p><p>旧版本的 macOS 中，在<code>/System/Library/Frameworks</code>下面有一个名为<code>Python.framework</code>的文件夹，这个文件夹内安装的就是 python2，但是从 12.3 开始，这个文件夹被移除了，相应的内置 python 环境也不复存在！</p><p>如今，即使在新版本的 macOS 中，在<code>/usr/bin</code>下面仍然有一个名为<code>python3</code>的可执行文件：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021161936567.png"></p><p>这个文件在所有版本的 macOS 系统中都存在，只是默认情况下是没有用的，即使<code>/usr/bin</code>目录在环境变量中，但是在执行 python3 命令时仍然会提示你当前系统没有 python 环境：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162254798.png"></p><p>需要注意的是：若你安装了命令行工具——Command Line Tools，那么<code>/usr/bin/python3</code>就会“变得可用”，它会指向 CLT 内置的 python3！当我们安装完 CLT 后，在终端中：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162403085.png"></p><p>所以，没安装命令行工具时，新版本的 macOS 中是没有 python 环境的，不管是 python2 还是python3；但一旦安装了命令行工具后，macOS 自带的 <code>/usr/bin/python3</code> 就会变得可用！</p><h2 id="1-2：CLT中的python"><a href="#1-2：CLT中的python" class="headerlink" title="1.2：CLT中的python"></a>1.2：CLT中的python</h2><p>那么安装 CLT 后，python3 被安装到哪里去了呢？其实它被安装到如下的位置了：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162557148.png"></p><p>至于为什么安装命令行工具后，<code>/usr/bin/python3</code>会指向这里，那就是 macOS 底层的处理了，没必要关心！</p><h2 id="1-3：放弃内置python"><a href="#1-3：放弃内置python" class="headerlink" title="1.3：放弃内置python"></a>1.3：放弃内置python</h2><p>即然命令行工具中内置了 python3，那么安装完命令行工具后，我们还有必要去自己安装 python3 吗？答案是：肯定有必要！为什么这么说呢，我个人认为主要有如下两个原因。</p><p>第一：命令行工具自带的 python3 是简化版的，版本较低，而且不会附带官方文档和 IDLE 等；而自己安装的话，不仅可以自由选择版本，而且还可以附带文档和 IDLE 等。</p><p>第二：使用命令行工具自带的<code>python3</code>可能会出现意料之外的问题。比如<code>pip3</code>的更新问题，直接更新的话，会在用户目录下生成<code>site-packages</code>文件夹，这样一来系统中就有了两个<code>site-packages</code>文件夹了；假如绕开权限（使用<code>sudo</code>前缀）来更新的话，虽然可以卸载旧版本的<code>pip3</code>，但是在安装新的<code>pip3</code>时，会在<code>/Library</code>中产生名为<code>Python</code>的文件夹，并在其中继续生成<code>site-packages</code>文件夹，并没有将新的<code>site-packages</code>文件夹放到旧版<code>site-packages</code>的位置，此外还会在<code>/usr/local/bin</code>中生成<code>pip3</code>和<code>pip</code>。虽然都不影响使用，但这无形之中在系统中添加了好多零零散散的目录，看起来很烦！假如后面产生和依赖相关的问题，势必会对定位问题产生不必要的困扰。</p><p>综合以上两点，我最终放弃了命令行内置的 python3，在我日常的开发中，我选择使用自己安装的 python3！<font color=red>友情提示</font>：假如你将命令行内置的 python3 作为基础环境，每次都是使用它来创建虚拟环境，然后在项目中继续使用的是你创建的虚拟环境，那命令行工具中内置的 python3 还是可以用的！</p><h1 id="第二节：下载安装"><a href="#第二节：下载安装" class="headerlink" title="第二节：下载安装"></a>第二节：下载安装</h1><h2 id="2-1：版本选择"><a href="#2-1：版本选择" class="headerlink" title="2.1：版本选择"></a>2.1：版本选择</h2><p>虽然 Python 官网说 3.9.1 已经原生支持 M 系列的芯片了，但我从官方下载了 3.9.1，在安装的过程中还是会提示我安装转译器 Rosetta！并且从 3.9.1 开始逐个地尝试，直到 3.9.10 开始（包括 3.9.10），在安装的过程中才不会提示我安装转译器！所以干脆我就选择了 3.9 的最后一个带有<code>.pkg</code>安装程序的版本——3.9.13！</p><p>登陆官网，找到 3.9.13 的下载链接，选择合适的版本来下载：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162916925.png"></p><p>下载下来的是一个<code>.pkg</code>格式的安装程序！</p><h2 id="2-2：安装步骤"><a href="#2-2：安装步骤" class="headerlink" title="2.2：安装步骤"></a>2.2：安装步骤</h2><p>双击安装包，进行傻瓜式安装即可！需要注意的是，安装过程中有个“自定”的选择，不要取消勾选，使用标准安装即可：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163226399.png"></p><p>安装完成以后，点击安装程序的“关闭”按钮，会自动跳出如下页面：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163354072.png"></p><p>这说明：安装程序会在<code>/Application</code>下面生成一个名为“Python 3.9”的文件夹，文件夹中的内容如上图所示！</p><h2 id="2-3：验证结果"><a href="#2-3：验证结果" class="headerlink" title="2.3：验证结果"></a>2.3：验证结果</h2><p>在安装之前是这样的：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021162403085.png"></p><p>而在安装之后是这样的：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163603311.png"></p><p>可见，此时我们系统默认的 python3 是我们手动安装的 3.9.13，而不是之前系统默认的 3.9.6（CLT 中内置的）！这就说明我们的安装是成功的！安装的位置就是<code>/library/Frameworks/Python.framework</code>目录！</p><h2 id="2-4：安装位置"><a href="#2-4：安装位置" class="headerlink" title="2.4：安装位置"></a>2.4：安装位置</h2><p>通过在终端中执行<code>which python3</code>命令，我们可以看到安装的python位置：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021163715058.png"></p><p>假如要卸载的话，首先要删除的就是<code>/Library/Frameworks/Python.framework</code>文件！</p><h2 id="2-5：环境变量"><a href="#2-5：环境变量" class="headerlink" title="2.5：环境变量"></a>2.5：环境变量</h2><p>使用安装程序来安装的 python3，是不需要配置环境变量的！为什么呢？</p><p>打开用户目录下的<code>.zprofile</code>文件，可见：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164102199.png"></p><p>假如你用户目录下原本没有这个文件，安装完以后也会自动生成这个文件并将上图红框内的内容写入！这个内容的意思就是把用户安装的 python 命令放到系统 PATH 变量的最前面：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164207519.png"></p><p>那<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中都有哪些命令呢？如下：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164320944.png"></p><p>所以此时我们不需要配置环境变量，因为位于<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中的这些命令已经被放到系统 PATH 变量的最前面了！</p><h2 id="2-6：符号连接"><a href="#2-6：符号连接" class="headerlink" title="2.6：符号连接"></a>2.6：符号连接</h2><p>安装程序还会在<code>/usr/local/bin</code>目录下创建一些符号链接，这些链接指向安装的命令：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164555245.png"></p><p>而<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中安装的这些命令原本就已经在系统的 PATH 中了，而且<code>/usr/local/bin</code>还在<code>/usr/bin</code>（命令行内置 python3 命令所在位置）的前面，再一次保证了我们不需要自己配置环境变量！</p><h1 id="第三节：更新-pip3"><a href="#第三节：更新-pip3" class="headerlink" title="第三节：更新 pip3"></a>第三节：更新 pip3</h1><h2 id="3-1：系统中的pip3"><a href="#3-1：系统中的pip3" class="headerlink" title="3.1：系统中的pip3"></a>3.1：系统中的pip3</h2><p>不管是通过命令行工具安装的还是我们自己通过安装程序安装的 python3，都会自带 pip3：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164730052.png"></p><p>显然，当前系统默认的 pip3 是我们自己安装的 python3 中的！</p><p>注意：跟 python 一样，在终端中使用 pip 的时候也需要使用<code>pip3</code>来替代<code>pip</code>，使用<code>pip</code>是无效的</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164908982.png"></p><h2 id="3-2：查看依赖"><a href="#3-2：查看依赖" class="headerlink" title="3.2：查看依赖"></a>3.2：查看依赖</h2><p>使用<code>pip3 list</code>可以查看当前 python3 环境都安装了哪些第三方库：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164843080.png"></p><p>注意：这个命令只能检测到当前 python3 环境可以使用的第三方库和模块，不包括内建的和标准的！</p><p>可见当前我们的 pip3 中只有两个库，一个是 pip3 本身，另外一个 setuptools 是支持 pip3 的：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021165049108.png"></p><p>记住 site-packages 这个路径，后面我们通过 pip3 下载安装的第三方库和模块都会被放到这里！</p><h2 id="3-3：最终做法"><a href="#3-3：最终做法" class="headerlink" title="3.3：最终做法"></a>3.3：最终做法</h2><p>跟命令行工具内置的 pip3 一样，使用安装程序安装的 python3 内置的 pip3 的版本也不是最新的，同样需要更新：</p><p><img src="https://www.czblogs.cn/posts/macos/10/image-20231021164843080.png"></p><p>回忆：我们尝试更新命令行工具自带的 pip3 时，会有如下问题</p><ul><li>直接更新的话，因为的权限问题，首先会导致原本的 pip3 卸载不掉，其次会将新的 pip3 安装到用户目录下，虽然不影响使用，但此时系统中会存在两个 site-packages 文件夹，当前 python3 可以使用这两个文件夹中的资源；</li><li>使用<code>sudo</code>来更新的话，虽然可以将原本的 pip3 卸载，但却没有把新版的 pip3 安装到旧版的 pip3 位置，而是安装到了<code>/Library/Python/site-packages</code>中了，并且会在<code>/usr/local/bin</code>中生成 pip3 和 pip 命令指向这里。假如这样的话，那么以后每次使用 pip3 都要在前面加上<code>sudo</code>，而且安装最后系统还是会给出提示“Running pip as the ‘root’ user can result in broken permissions and conflicting behaviour with the system package manager”，所以最终放弃这种方案；</li></ul><p>而更新自己安装的 python3 中自带的 pip3 时，就不会遇到这样的问题，直接使用终端中提示的命令就可以更新成功！</p><p><font color='red'>但是，更新以后终端中可以同时识别“pip3”和“pip”这两个命令</font>！这是因为新版的 pip 会同时安装<code>pip</code>和<code>pip3</code>两个命令，所以我干脆就不更新了，理由有三：</p><ul><li>不更新也能使用，又不是必须的，只是会出现更新的提示；</li><li>今后不打算直接使用系统默认的 python3，而是用它来创建虚拟环境（即使更新了系统默认的 pip3，创建的虚拟环境对应的 pip3 依然是新安装时未更新的 pip3 版本，所以从这方面看，更新 pip3 也是没必要的）；</li><li>在 macOS 上，我更愿意用“pip3”而非“pip”（因为在命令行中我们也只能使用“python3”而不是“python”，就要整整齐齐，装逼就要装个整套的）；</li></ul><h1 id="第四节：总结归纳"><a href="#第四节：总结归纳" class="headerlink" title="第四节：总结归纳"></a>第四节：总结归纳</h1><h2 id="4-1：安装所得"><a href="#4-1：安装所得" class="headerlink" title="4.1：安装所得"></a>4.1：安装所得</h2><p>在整个手动安装 python3 的过程中，安装程序总共做了下面几件事：</p><ul><li><p>生成<code>/Application/Python 3.9</code>文件；</p></li><li><p>生成<code>/Library/Frameworks/Python.framework</code>文件，这是实际安装的 python3 文件；</p></li><li><p>生成<code>~/.zprofile</code>文件，将安装的 python3 添加到环境变量中；</p><p>假如系统中原本就有这个文件，就会在文件末尾追加配置环境的内容</p></li><li><p>生成一些链接，在<code>/usr/local/bin</code>中；</p><p>这些链接指向<code>/Library/Frameworks/Python.framework/Versions/3.9/bin</code>中的命令；</p></li></ul><p>假如要卸载的话，只需要去复原上面这四项即可！</p><h2 id="4-2：系统环境"><a href="#4-2：系统环境" class="headerlink" title="4.2：系统环境"></a>4.2：系统环境</h2><p>经过安装命令行工具 CLT 和手动安装 python 3.9.13，此时系统中有两个版本的 python3 环境：</p><ul><li>&#x2F;Library&#x2F;Developer&#x2F;CommandLineTools&#x2F;Library&#x2F;Frameworks&#x2F;Python3.framework&#x2F;Versions&#x2F;3.9</li><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9</li></ul><p>前者是命令行工具中内置的，后者是我们手动安装的，而且此时如下的 python3 命令都是指我们自己安装的：</p><ul><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3.9</li><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;python3</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3.9</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;python3</li></ul><p>而如下的 pip3 指向我们手动安装的 pip3：</p><ul><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3.9</li><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;bin&#x2F;pip3</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3.9</li><li>&#x2F;usr&#x2F;local&#x2F;bin&#x2F;pip3</li></ul><p>此时，在终端中直接使用 pip3 命令来安装依赖时，依赖会被安装到如下目录：</p><ul><li>&#x2F;Library&#x2F;Frameworks&#x2F;Python.framework&#x2F;Versions&#x2F;3.9&#x2F;lib&#x2F;python3.9&#x2F;site-packages</li></ul>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Python </tag>
            
            <tag> 命令行工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>在macOS上安装配置Nodejs的保姆级教程</title>
      <link href="/post/9.html"/>
      <url>/post/9.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：什么是-Nodejs"><a href="#第一节：什么是-Nodejs" class="headerlink" title="第一节：什么是 Nodejs?"></a>第一节：什么是 Nodejs?</h1><blockquote><p>简单来说：Nodejs 是一个基于 Chrome V8 开发的 JavaScript 的运行环境，能够使 JavaScript 脱离浏览器运行！</p></blockquote><p>Node.js 是 2009 的时候由大神 Ryan Dahl 开发的。Ryan 的本职工作是用 C++ 写服务器，后来他总结出一个经验，一个高性能服务器应该是满足“事件驱动，非阻塞 I&#x2F;O”模型的。C++ 开发起来比较麻烦，于是 Ryan 就想找一种更高级的语言，以便快速开发。</p><p>可以说有两点促成了 Nodejs 的诞生。首先第一点，Ryan 发现 JS 语言本身的特点就是事件驱动并且是非阻塞 I&#x2F;O 的，跟他的思路正是绝配；第二点，Chrome 的 JS 引擎，也就是 V8 引擎是开源的，而且性能特别棒。于是 Ryan 就基于  Chrome V8 开发了 Node.js 。</p><p>注意：Node.js 听起来好像是个 JS 库，其实不是的，Node.js 是使用 C++ 开发的，到官网 <a href="https://link.zhihu.com/?target=http://nodejs.org">http://nodejs.org</a> 可以看到！所以说：<font color='red'>Node.js不是库，而是一个运行环境，或者说是一个JS语言解释器！</font></p><h2 id="1-1：执行JS代码"><a href="#1-1：执行JS代码" class="headerlink" title="1.1：执行JS代码"></a>1.1：执行JS代码</h2><p>以前 JavaScript 只能运行在浏览器中，Node.js 出现之后，不管是服务器上还是我们自己的笔记本，只要是你安装了 Nodejs，就可以运行 JavaScrip t代码了！</p><p>比如，安装完 Nodejs 以后，进入命令行以后执行命令<code>node</code>进入 Nodejs 环境以后，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 + 1</span><br></pre></td></tr></table></figure><p>这段JS代码就是简单的执行加法操作，回车后就可以看到代码正确执行了。</p><p>跟 python 相同，我们还可以将JS代码编写在<code>.js</code>文件中，然后使用 Nodejs 环境直接执行改文件。比如在<code>test.js</code>文件中编写如下代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hello&quot;</span>);</span><br></pre></td></tr></table></figure><p>然后在命令行中这样执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure><p>此时“hello”会被打印出来，而这种执行过程跟浏览器没有一毛钱关系，<font color='red'>Nodejs使得JS代码脱离了浏览器的限制！</font></p><p>PS：当然 Nodejs 跟浏览器还是有一些细微的区别的，这里我们先不关注。</p><h2 id="1-2：内置包管理器"><a href="#1-2：内置包管理器" class="headerlink" title="1.2：内置包管理器"></a>1.2：内置包管理器</h2><p>Nodejs 的出现，引发了前后端开发的爆发（尤其是前端），众多的JS开发者贡献了非常多的开源代码，所有这些优秀的代码就凝结成了一个仓库——世界上最大的包管理器 npm！</p><p>不知道在座的各位有没有用过 Python，Python 有一个很优秀的包管理器 pip，通过 pip 我们可以获取其他 Python 开发者写好的优秀代码，并将其引用到我们自己的项目中来。npm 同样如此，它是 Nodejs 的包管理器，通过 npm 我们可以简单的获取其他开发者的优秀代码，并将其引用到我们的项目中，避免“重复造轮子”！<font color='red'>跟 pip 一样，npm 既是一个代码库，也是一个程序，当系统安装上 Nodejs 以后，会内置安装 npm</font>！</p><p>比如，安装完 Nodejs 后，我们想使用 npm 安装一个名为 moment 的代码库，就可以直接执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install moment</span><br></pre></td></tr></table></figure><p>这个命令可以直接把 moment 这个包从 npm 的软件包仓库中下载这个包并安装到本地，而在 npm 仓库中还有这数以万计的类似 moment 这样的包！</p><p>关于 npm ，我们暂时理解到这个程度就可以了，只要求会用！</p><h1 id="第二节：下载安装"><a href="#第二节：下载安装" class="headerlink" title="第二节：下载安装"></a>第二节：下载安装</h1><h2 id="2-1：下载"><a href="#2-1：下载" class="headerlink" title="2.1：下载"></a>2.1：下载</h2><p>浏览器访问<a href="https://nodejs.org/">Nodejs的官网</a>：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021152549673.png"></p><p>PS：LTS 版本是长期维护的稳定版本，Current 是当前开发版本，一般情况下，我们选择 LTS 版本的下载。</p><p>也可以通过 Downloads 页签找到更多的选择，比如我选择的是同时支持 Intel 和苹果 Silicon 的 macOS 安装程序：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021152853040.png"></p><p>PS：如此流行的 Nodejs，比其他开发环境更早的适配 ARM 架构（真的很牛逼，很多比较常用的开发环境对于 ARM 架构的支持都是比较滞后的），这对使用苹果芯片的 macOS 用户来说简直是太棒了！下载下来的是一个<code>.pkg</code>的安装程序。</p><h2 id="2-2：安装"><a href="#2-2：安装" class="headerlink" title="2.2：安装"></a>2.2：安装</h2><p>直接双击下载下来的安装程序，进入安装程序：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153158616.png"></p><p>友情提示：</p><ul><li><p>安装程序会安装 node，并将其安装到<code>/usr/local/bin/node</code>目录；</p></li><li><p>安装程序会安装 npm，并将其安装到<code>/usr/local/bin/npm</code>目录；</p></li><li><p>假如你此前没使用过<code>/usr/local</code>目录的话，此时这个目录应该是空的（比如我在安装前，这个目录就是空的）；</p></li></ul><p>点击上图中右下角的“继续”，会展示软件许可协议：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153353254.png"></p><p>点击上图中的“继续”：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153507248.png"></p><p>然后点击上图中的“同意”：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153623806.png"></p><p>假如此时点击“自定”，我们看到安装程序会安装 Node.js 和 npm：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153715916.png"></p><p>这里不需要修改，直接点击“安装”，输入机器开机密码后，即可进入自动安装！最后点击“关闭”来完成安装：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021153859069.png"></p><h2 id="2-3：配置"><a href="#2-3：配置" class="headerlink" title="2.3：配置"></a>2.3：配置</h2><p>为了能在命令行中使用 Nodejs，我们需要确认安装的 node 和 npm 在我们的系统的环境变量 PATH 中。但是这两者的安装位置<code>/usr/local/bin/</code>本身就在 Mac 的环境变量 PATH 中，这是系统预置的：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154036625.png"></p><p><font color='red'>也就是说：使用安装程序安装的Nodejs，不需要我们再自己手动的设置环境变量了！</font></p><h2 id="2-4：检查"><a href="#2-4：检查" class="headerlink" title="2.4：检查"></a>2.4：检查</h2><p>打开终端，查看 node 和 npm 的版本号，假如能正确查看到版本号，则说明安装成功：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154420969.png"></p><h2 id="2-5：-npm"><a href="#2-5：-npm" class="headerlink" title="2.5：.npm"></a>2.5：.npm</h2><p>安装 Nodejs 获得的文件：</p><ul><li>安装的 Nodejs 的所有的文件都安装到<code>/usr/local</code>目录中（这个目录原本是空的）；</li><li>安装完 Nodejs 后，用户目录下没有<code>.npm</code>文件，执行<code>npm</code>命令后，用户目录下会产生名为<code>.npm</code>的隐藏文件；</li></ul><p>刚安装 Nodejs 后，用户目录下有如下文件：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154318574.png"></p><p>当执行了 2.4 中的<code>npm</code>命令后，就会再用户目录下生成名为<code>.npm</code>的文件：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154529947.png"></p><p>友情提示：</p><ul><li>因为<code>npm</code>命令在环境变量中，所以可以在任意目录下执行<code>npm</code>命令；</li><li>无论在哪个目录下执行<code>npm</code>命令，都会在用户目录下生成名为<code>.npm</code>的隐藏文件！</li></ul><h1 id="第三节：额外配置"><a href="#第三节：额外配置" class="headerlink" title="第三节：额外配置"></a>第三节：额外配置</h1><p>当使用 npm 来安装第三方软件包的时候，有局部安装和全局安装两种安装类型，对应的命令分别是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install 软件包名</span><br><span class="line">npm install -g 软件包名</span><br></pre></td></tr></table></figure><p>前者表示局部安装，后者表示全局安装！使用“<font color='red'>npm root</font>”命令可以查看局部安装和全局安装的目标目录：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154657299.png"></p><p>友情提示：</p><ul><li>局部安装时，软件包会被安装到执行安装命令的目录下（假如执行安装命令的路径下有<code>node_modules</code>），或者被安装到当前用户目录下的<code>node_modules</code>文件夹中（假如执行安装命令的路径下没有<code>node_modules</code>）；</li><li>全局安装时，软件包会被安装到<code>/usr/local/lib/mode_modules</code>文件夹中；</li></ul><h2 id="3-1：局部安装"><a href="#3-1：局部安装" class="headerlink" title="3.1：局部安装"></a>3.1：局部安装</h2><p>在局部安装之前，用户目录下的文件目录是这样的（用户目录下的<code>.npm</code>文件是只要执行<code>npm</code>命令就会产生的）：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154809551.png"></p><p>下面，我们试着在用户目录下局部安装一个名为<code>moment</code>库，在用户目录下执行<code>npm install moment</code>：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154902742.png"></p><p>PS：其实安装的时候，终端中会有进度条展示，但是网速比较快的话，基本捕捉不到进度条！</p><p>此时查看用户目录，可见这里会产生三个新的文件（用户目录下的<code>.npm</code>文件是只要执行<code>npm</code>命令就会产生或更新）：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155002595.png"></p><p><font color=red>友情提醒</font>：其中安装的 moment 包就放在<code>node_modules</code>文件夹中，使用<code>npm uninstall moment</code>命令卸载时，只会将<code>~/node_modules/</code>中的<code>moment</code>文件夹删掉，上图中新生成的这三个文件夹不会被删除！</p><p><font color='red'><strong>综上</strong></font>：</p><ul><li>使用局部安装的方式，不需要额外的任何配置；</li><li>局部安装时，软件包会被安装到执行安装命令的目录下（假如执行安装命令的路径下有<code>node_modules</code>），或者被安装到当前用户目录下的<code>node_modules</code>文件夹中（假如执行安装命令的路径下没有<code>node_modules</code>）；</li></ul><h2 id="3-2：全局安装"><a href="#3-2：全局安装" class="headerlink" title="3.2：全局安装"></a>3.2：全局安装</h2><p>局部安装时，会在安装目录下生成<code>node_modules</code>目录，但是全局安装的目标目录<code>/usr/local/lib/node_modules</code>本身就存在（package-local.json 和 package.json不存在），并且里面本身就存在两个包（这是自带的两个包）：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155518502.png"></p><p>直接执行命令<code>npm install -g moment</code>来全局安装 moment 包：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155406170.png"></p><p>执行报错！因为执行全局安装时，npm 会默认将软件包安装到<code>/usr/local/lib/node_modules/</code>目录下，但是从<code>/usr</code>到<code>/usr/local/lib/node_modules/</code>这些目录的权限全是<code>drwxr-xr-x</code>，并且权限属主是 root、属组是 wheel！</p><p>PS：macOS 系统的权限控制</p><ul><li>macOS 系统中有 staff、admin、wheel 这三种用户组；</li><li>staff：所有的用户都属于这个组，这是用户的一个超集；</li><li>admin：这个组中的用户可以使用<code>su</code>或<code>sudo</code>切换到 root 用户，只需要输入自己的密码即可，不用 root 密码；</li><li>wheel：这个组只有一个 root 用户，是 root 用户的专属组；</li></ul><p>所以，对于<code>drwxr-xr-x</code>而言，正常情况下 admin 用户对它不具备写的权限！这也是为什么上面会报错的原因！</p><p>解决这个问题，有两种思路：</p><ul><li><p>方法一：使用<code>sudo npm install -g moment</code>命令代替<code>npm install -g moment</code></p><p>  root 用户对<code>/usr/local/lib/node_modules/</code>有写的权限，所以使用<code>sudo</code>让管理员用户暂时具备 root 用户的权限，这样就可以完成安装了！虽然这样可以成功安装软件包到<code>/usr/local/lib/node_modules/</code>中，但是这种方式是不可取的！因为<code>sudo</code>只对当前命令有效，假如我们执行的是更新语句的话，分为卸载和安装两个步骤，<code>sudo</code>只对卸载旧版本有效，对安装新版本就无效了，所以不能使用这种方式；</p><p>  <font color=red>我们在使用 npm 进行全局安装时，应该尽量避免甚至完全不用<code>sudo</code>！</font></p></li><li><p>方法二：修改<code>/usr/local/lib/node_modules/</code>的权限，让其他用户（包括 admin）对该目录具备写权限</p><p>  因为 admin 对<code>node_modules</code>的所有上级目录都具备可执行权限，在这种情况下，只要它再对<code>node_modules</code>具备写的权限，那么 admin 就可以写这个目录了，这是 Linux 的权限机制！</p><p>  <font color=red>显然这种方式更可取，这样在安装的时候就可以不用<code>sudo</code>了，而且可以一劳永逸！</font></p></li></ul><p>具体的操作步骤：</p><ol><li><p>打开终端，执行如下命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 757 /usr/local/lib/node_modules</span><br></pre></td></tr></table></figure><p>这一步是为了让 admin 用户对<code>/usr/local/lib/node_modules/</code>具备写的权限！</p></li><li><p>打开终端，继续执行命令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 757 /usr/local/bin</span><br></pre></td></tr></table></figure><p>因为在全局安装时，经常需要在<code>/usr/local/bin</code>中创建一些软连接，并让它们指向下载的包中的真实的命令，所以我们同时需要让当前用户（admin）对<code>/usr/local/bin</code>也具备写的权限！这一步就是做这个的。</p></li></ol><p>经过这两个命令以后，使用全局安装的时候，就能轻松地将软件包安装到<code>/usr/local/lib/node_modules/</code>中了，并且伺候不管是下载、安装还是更新，都能一劳永逸！比如此时我全局安装 moment 包就可以成功：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155805416.png"></p><p><font color='red'><strong>综上</strong></font>：安装完 Nodejs 后，使用全局安装之前，需要使用如下两个命令来改变文件的权限，仅此而已</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod 757 /usr/local/lib/node_modules</span><br><span class="line">sudo chmod 757 /usr/local/bin</span><br></pre></td></tr></table></figure><p>在使用 npm 全局安装包的时候，就单纯的安装操作而言，我们直接使用<code>sudo</code> 配合<code>-g</code>参数就可以安装完成，后续也不影响对所安装软件包的使用（因为管理员用户对这个目录具备读的权限），但是为了简化每一次的安装和卸载，所以我修改了<code>/usr/local/lib/node_modules/</code>的权限；其次，为了能顺利在<code>/usr/local/bin</code>中创建能指向安装包中的命令的软连接，还需要修改<code>/usr/local/bin</code>的权限。二者缺一不可，一劳永逸！</p><p>全局安装时，包会被安装到<code>/usr/local/lib/node_modules/</code>目录下（目录本就存在，但要修改该权限）；</p><p><font color='red'><strong>注意</strong></font>：全局安装的包，在卸载时也需要使用<code>-g</code>参数来全局卸载！</p><h2 id="3-3：换镜像源"><a href="#3-3：换镜像源" class="headerlink" title="3.3：换镜像源"></a>3.3：换镜像源</h2><p>所谓 npm 镜像源，就是指使用<code>npm</code>命令来安装包的时候，通过网络下载的包的来源。</p><p>执行命令<code>npm config get registry</code>可以查看 npm 的镜像源，默认的镜像源是：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021155905051.png"></p><p>默认的镜像源是国外的，有时候我们在国内使用 npm 默认的镜像源时，会因为网络问题导致失败。在这种情况下我们可以更换为国内的镜像源，常见的 npm 镜像源有如下三种：</p><ul><li>腾讯镜像源：<a href="http://mirrors.cloud.tencent.com/npm/">http://mirrors.cloud.tencent.com/npm/</a></li><li>淘宝镜像源：<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></li><li>华为镜像源：<a href="https://mirrors.huaweicloud.com/repository/npm/">https://mirrors.huaweicloud.com/repository/npm/</a></li></ul><p>此外，更换镜像源的方式有两种：</p><ul><li><p><font color='red'>暂时修改镜像源</font></p><p>比如使用淘宝源全局下载 moment，可以执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm --registry https://registry.npmmirror.com install -g moment</span><br></pre></td></tr></table></figure><p>这种方式不会修改 npm 默认的镜像源，下次使用<code>npm install</code>命令来安装时，依然使用 npm 默认的镜像源！而卸载的时候就不需要指定镜像源了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall -g moment</span><br></pre></td></tr></table></figure></li><li><p><font color='red'>永久修改镜像源</font></p><p>我们可以永久修改 npm 镜像源，这样一来每次都可以使用我们配置的镜像源来下载，而不用指定镜像源：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=https://registry.npmmirror.com</span><br></pre></td></tr></table></figure><p>对 npm 进行了自己的配置后，会在用户目录下生成名为<code>.npmrc</code>的隐藏文件，以“key&#x3D;value”的形式记录配置！</p><p>注意这里不要添加<code>-g</code>参数，如果添加了的话，就只是修改了全局安装时的镜像源，局部安装的镜像源没有修改！</p></li></ul><p>PS：我们还可以使用 npm 安装 cnpm，因为 cnpm 默认使用淘宝源，但我不推荐，因为 cnpm 的安装目录比较奇怪！</p><h2 id="3-4：更新npm"><a href="#3-4：更新npm" class="headerlink" title="3.4：更新npm"></a>3.4：更新npm</h2><p>一般 Nodejs 中自带的 npm 不是最新的，需要更新 npm。比如前面我第一次使用 npm 安装 moment 时，就给出了提示：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021154902742.png"></p><p>当然，假如你第一次忽略了这个版本提醒，后面再使用时就不会给出版本提醒了，除非你删除了用户目录下的<code>.npm</code>文件后再执行<code>npm</code>命令！</p><p>我们可以使用命令如下命令来查看当前 npm 的最新版本：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm view npm version</span><br></pre></td></tr></table></figure><p>比如我这里：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021160311613.png"></p><p>但是此时若直接执行更新命令<code>npm install -g npm@10.2.1</code>的话，会出现错误：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021160839704.png"></p><p>其实这里的问题跟本文 3.2 中的情况是相同的，同样需要处理权限问题，我这里就不再赘述了（我觉得其实也没必要更新它，只要不删除用户目录下的<code>.npm</code>文件的话，以后在使用它的时候不会再提示更新）！</p><h1 id="第四节：常用命令"><a href="#第四节：常用命令" class="headerlink" title="第四节：常用命令"></a>第四节：常用命令</h1><p>npm 的命令都采用<code>命令</code>+<code>参数</code>的形式！</p><h2 id="4-1：帮助"><a href="#4-1：帮助" class="headerlink" title="4.1：帮助"></a>4.1：帮助</h2><p>在 npm 中，有一个最重要的命令，就是<code>npm help</code>，这个命令可以查看所有其他 npm 命令的用法：</p><p><img src="https://www.czblogs.cn/posts/macos/09/image-20231021161452100.png"></p><p>假如要查看某个特定命令的用法，可以使用<code>npm help 命令</code>，比如查看<code>config</code>命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm help config</span><br></pre></td></tr></table></figure><h2 id="4-2：配置"><a href="#4-2：配置" class="headerlink" title="4.2：配置"></a>4.2：配置</h2><ul><li><p>使用<code>npm config key=value</code>进行配置，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set registry=https://registry.npmmirror.com  # 这里的等号也可以用空格替代</span><br></pre></td></tr></table></figure></li><li><p>使用<code>npm config get key</code>查看配置，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config get registry # 假如要查看多个，可以用空格隔开</span><br></pre></td></tr></table></figure></li></ul><p>所有的使用细节，可以使用<code>npm config --help</code>来查看大概用法，使用<code>npm help config</code>来查看详细用法！</p><h2 id="4-3：安装"><a href="#4-3：安装" class="headerlink" title="4.3：安装"></a>4.3：安装</h2><p>安装指定包，默认是局部安装，<code>-g</code>参数表示全局安装：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install [-g] package</span><br></pre></td></tr></table></figure><h2 id="4-4：更新"><a href="#4-4：更新" class="headerlink" title="4.4：更新"></a>4.4：更新</h2><p>更新指定包，默认是局部更新，<code>-g</code>参数表示全局更新：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm update [-g] package</span><br></pre></td></tr></table></figure><h2 id="4-4：卸载"><a href="#4-4：卸载" class="headerlink" title="4.4：卸载"></a>4.4：卸载</h2><p>卸载指定包，默认是局部卸载，<code>-g</code>参数表示全局卸载：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm uninstall [-g] package</span><br></pre></td></tr></table></figure><h2 id="4-5：查看"><a href="#4-5：查看" class="headerlink" title="4.5：查看"></a>4.5：查看</h2><p>查看当前安装的软件包，默认查看局部安装的软件包，<code>-g</code>参数表示查看全局安装的软件包：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm list [-g]</span><br></pre></td></tr></table></figure><p>查看软件包的安装位置，默认是查看局部安装位置，<code>-g</code>参数表示查看全局安装位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root [-g]</span><br></pre></td></tr></table></figure><p>查看具体某个软件包的安装位置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm root package</span><br></pre></td></tr></table></figure><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Nodejs </tag>
            
            <tag> npm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Homebrew的安装配置和使用</title>
      <link href="/post/8.html"/>
      <url>/post/8.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><p>Homebrew 是 macOS 平台上最常用也是最好用的一个包管理工具，使用它给 Mac 下载、安装、卸载软件时，基本上都只需要一条命令，如果你是一位使用Mac的开发者，还没有安装Homebrew的话，那就太不应该了！</p><p>这里我要先声明两点：</p><ul><li><p>英特尔芯片的 Mac 安装 Homebrew 是很简单的，默认安装位置是<code>/usr/local</code>，我这里就不再赘述了；</p></li><li><p>苹果芯片的 Mac 刚出来的时候，安装 Homebrew 是比较复杂的。第一，是因为默认安装的目录跟 英特尔芯片的电脑不同，默认安装的位置是<code>/opt/homebrew</code>；第二，是需要处理一些文件夹的权限问题，但随着 Homebrew 的版本更新，虽然默认的安装位置没变，但是截止到我写这篇博文的时间，也就是 2023 年 9 月 8 日，已经不需要再额外处理权限问题了！</p></li></ul><p>这篇博文详细记录了如何在苹果芯片的 macOS 上安装和使用支持 ARM 架构的 Homebrew！</p><h1 id="第二节：检测环境"><a href="#第二节：检测环境" class="headerlink" title="第二节：检测环境"></a>第二节：检测环境</h1><p>在安装 Homebrew 之前，首先查看目录<code>/opt/</code>下面没有名为<code>homebrew</code>的子目录，我这是一台新电脑，显然没有：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021132854441.png"></p><p>其次，还需要在终端中执行命令<code>brew --version</code>来检测是否存在 Homebrew，当然也不会有的：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021133045993.png"></p><p>综合以上两点，说明当前环境中并没有安装 Homebrew！就算不是新的电脑，假如满足这两个条件，我们也可以认为当前系统中不存在 Homebrew！</p><p>PS：在安装软件之前检测本机是否已经安装了要安装的软件，这是一个必要的操作，也是一个好习惯！</p><h1 id="第三节：安装条件"><a href="#第三节：安装条件" class="headerlink" title="第三节：安装条件"></a>第三节：安装条件</h1><p>打开<a href="https://brew.sh/index_zh-cn">Homebrew的官网</a>，首页赫然展示的就是安装 Homebrew 的命令：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021133925788.png"></p><p>其实，只需要将这里的命令复制到终端中执行，即可完成安装。但是在安装之前，点击上图中的<code>这里</code>，可见：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021144620878.png"></p><p>这是安装 Homebrew 时，macOS 需要满足的条件：</p><ul><li>搭载 Intel 芯片或苹果芯片的 macOS（废话）；</li><li>macOS 的版本至少要在 11 以上；</li><li>必须提前安装命令行开发者工具（CLT）；</li><li>必须使用Bourne-again shell（Bash）终端来安装，Mac 是自带 bash 终端的，即<code>/usr/bin/bash</code>；</li></ul><p>其中有这么一条：<font color='red'>必须提前安装命令行开发者工具</font>！命令行开发者工具是将Mac作为开发工具的第一步操作，我不信还有人的Mac没有安装 CLT！！！</p><h1 id="第四节：安装程序"><a href="#第四节：安装程序" class="headerlink" title="第四节：安装程序"></a>第四节：安装程序</h1><p>在官网上，安装条件的第四条说明了，必须使用 bash，使用其他常规的 shell 将会失败：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021144956117.png"></p><p><font color=red>友情提示</font>：较新版本的 macOS 终端默认使用的是 zsh（包括我这里的 14.0），我试过使用 zsh 安装，结果是也能安装成功，我觉得是 Homebrew 的官网上信息很久没更新了，因为较老版本的 macOS 的终端默认是使用 bash 的，现在已经默认使用 zsh 了！但是为了保险起见，我还是使用<code>/bin/bash</code>来执行安装的命令！</p><p>打开访达，切换到<code>/bin</code>，右击<code>bash</code>选择使用终端打开，再把官网上的安装命令贴进去：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145241014.png"></p><p>按下回车需要输入开机密码：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145345605.png"></p><p>输入密码并回车（注意输入密码的时候，键入的密码并不会出现在终端中，你只管正确输入即可）后，开始安装：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145511355.png"></p><p>此时键入回车键，继续安装，直到最后安装成功：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145709620.png"></p><p>从这里可以看出来，Homebrew安装成功了！查看目录<code>/opt</code>中的内容，可以看到安装的 Homebrew：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021145953498.png"></p><h1 id="第五节：配置环境"><a href="#第五节：配置环境" class="headerlink" title="第五节：配置环境"></a>第五节：配置环境</h1><h2 id="5-1：官方推荐"><a href="#5-1：官方推荐" class="headerlink" title="5.1：官方推荐"></a>5.1：官方推荐</h2><p>安装 Homebrew 前后，macOS 的系统 PATH 变量没有任何变化：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150312442.png"></p><p>安装程序的最后给出提示，安装的 Homebrew 并不在我们的环境变量中，并且还给出了如何配置环境变量的方法：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150433799.png"></p><p>将推荐中的两条命令复制下来依次拿到终端中去执行就能配置环境变量了，之后会在用户目录下生成名为<code>.zprofile</code>的配置文件，文件内容为：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval &quot;$(/opt/homebrew/bin/brew shellenv)&quot;</span><br></pre></td></tr></table></figure><p>然后使用命令<code>echo $PATH</code>查看系统的 PATH 变量的话，会再原本 PATH 变量的最前面，添加如下内容：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/opt/homebrew/bin:/opt/homebrew/sbin:</span><br></pre></td></tr></table></figure><p><font color='red'><strong>说明</strong></font>：文件<code>.zprofile</code>中的内容就是把<code>/opt/homebrew/bin</code>和<code>/opt/homebrew/sbin</code>加到系统 PATH 里面了！</p><h2 id="5-2：我的推荐"><a href="#5-2：我的推荐" class="headerlink" title="5.2：我的推荐"></a>5.2：我的推荐</h2><p>前面的方式是 Homebrew 的推荐方式，除此之外，我们还可以按照自己习惯的方式来配置环境变量！</p><p>打开终端，<font color=red>在用户目录下</font>找到（或新建）名为<code>.zprofile</code>的文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim .zprofile</span><br></pre></td></tr></table></figure><p>然后将下面的内容粘贴进去（假如文件中已经存在其他内容，就将下面的内容追加在文件的最后）：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Setting PATH for Homebrew</span><br><span class="line">PATH=&quot;/opt/homebrew/bin:/opt/homebrew/sbin:$&#123;PATH&#125;&quot;</span><br><span class="line">export PATH</span><br></pre></td></tr></table></figure><p>这种方式跟前面的方式一样，重启终端后查看 PATH 变量，发现同样会：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150744449.png"></p><h1 id="第六节：检测结果"><a href="#第六节：检测结果" class="headerlink" title="第六节：检测结果"></a>第六节：检测结果</h1><p>经过上面的三步操作以后，按道理讲 Homebrew 就安装完成了，重新打开终端，直接执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew --version</span><br></pre></td></tr></table></figure><p>假如此时能正确输出 Homebrew 的版本号，就表示安装和配置成功了： </p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021150843552.png"></p><h1 id="第七节：使用细节"><a href="#第七节：使用细节" class="headerlink" title="第七节：使用细节"></a>第七节：使用细节</h1><p><font color=red>友情提示：以下内容是 2023-10-21 日更新！</font></p><p>这一节的主要内容是分析 Homebrew 的使用细节，比如使用<code>brew install 软件包</code>来安装软件时，软件被安装到了系统的什么位置，以及创建了什么样的软连接，再比如使用<code>brew uninstall 软件包</code>来卸载软件时的细节！</p><h2 id="7-1：软件安装"><a href="#7-1：软件安装" class="headerlink" title="7.1：软件安装"></a>7.1：软件安装</h2><p>在 Homebrew 的官网上有这么一段描述：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021151236600.png"></p><p>也就是说，Homebrew 会将软件安装到“独立目录”，通过配图可知，所谓的独立目录就是<code>/opt/homebrew/Cellar</code>！</p><p>我们可以做一个实验！打开终端，执行命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install tree</span><br></pre></td></tr></table></figure><p>执行的情况为：</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021151526811.png"></p><p>通过比对系统前后的文件，发现安装命令做了如下两件事。</p><p>第一：软件包被安装到<code>/opt/homebrew/Cella</code>目录中了（这个目录原本是空的）；</p><p>第二：在<code>/opt/homebrew/bin</code>下面创建了一个名为<code>tree</code>的软连接，链接至安装的软件包中的真实命令</p><p><img src="https://www.czblogs.cn/posts/macos/08/image-20231021151712919.png"></p><p><font color=red>也就是说：使用 Homebrew 安装软件时，只会影响 Homebrew 自己的安装目录，不会影响到系统中其他任何目录！</font>正是因为我们在配置 Homebrew 时将目录<code>/opt/homebrew/bin</code>配置到系统的 PATH 环境变量中了，所以此时我们就可以使用其中安装的命令了！</p><p><font color=red>特别注意</font>：假如使用 Homebrew 安装系统中<code>/usr/bin</code>中原本就存在的命令时，会覆盖原本的命令，不是说修改了原本命令的链接，而是因为 Homebrew 在系统环境变量 PATH 中的位置<code>/opt/homebrew/bin</code>在<code>/usr/bin</code>之前！同时，因为它也在<code>/usr/local/bin</code>前面，也会覆盖 Nodejs 安装的命令！！！</p><h2 id="7-2：软件卸载"><a href="#7-2：软件卸载" class="headerlink" title="7.2：软件卸载"></a>7.2：软件卸载</h2><p>使用命令<code>brew uninstall 软件包</code>来卸载软件的时候，就会将安装软件时做的那两件事“复原”，这里就不赘述了！</p><p>～～</p><p>～～</p><p>～～</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Homebrew </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果芯片的macOS安装Git</title>
      <link href="/post/7.html"/>
      <url>/post/7.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><p>对于开发人员而言，肯定都使用过 Git，而且基本上每天都在使用，但是在 Windows 和 macOS 上安装 Git 是不同的：</p><ul><li><p>在 Windows 平台上安装很简单，只需要下载下来安装程序，进行傻瓜式安装就可以了。需要主要的是：因为 Git 的官网是国外的网站，直接从官网上下载的话，经常会因为网络问题而失败，常用的解决方式就是借助淘宝的 NPM 镜像站来下载。</p><p>友情提示：从 2022 年 05 月 31 日开始，淘宝 npm 镜像源的域名更改为：<a href="https://registry.npmmirror.com/">https://registry.npmmirror.com</a></p></li><li><p>在 macOS 平台上，安装 Git 有很多种方式，比如使用 Command Line Tools 或 Homebrew，虽然安装的方式有很多种，但是相对而言较简单。</p></li></ul><p>这篇博文的主要内容就是介绍如何在 macOS 平台上安装配置 Git，并且解释一些 Git 的配置原理！</p><h1 id="第二节：安装-Git"><a href="#第二节：安装-Git" class="headerlink" title="第二节：安装 Git"></a>第二节：安装 Git</h1><p>在 macOS 上安装 Git，不管是 Intel 芯片还是苹果芯片的电脑，最简单的方式就是通过安装命令行工具（Command Line Tools）！<font color='red'>实际上，命令行工具中内置 Git，根本不需要自己再去下载安装 Git，这也是我推荐的方式！</font></p><p>关于如何给 macOS 安装命令行工具，以及安装命令行工具后系统的变化，都不是这篇博文的重点，在这里就不赘述了！</p><p>在安装命令行工具之前，假如你还没安装 Git 的话，这个时候执行命令<code>git --version</code>，可见系统中找不到 Git：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143147454.png"></p><p>刚安装完命令行工具后，再执行该命令后可见：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143259395.png"></p><p>顺便提一句，在没安装命令行工具之前，系统的<code>/usr/bin/</code>目录下就已经有名为<code>git</code>的可执行文件：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143308310.png"></p><p><font color='red'>安装完命令行工具后，这里的可执行文件就自动指向了其中安装的 Git</font>。跟 python3 一样，即使不安装命令行工具，该目录下也有这个命令，只是在安装完以后，<code>/usr/bin/python3</code>就会自动指向命令行工具中内置的 python 环境，并且从文件上来看并没有生成链接，这是 macOS 和 CLT 本身的处理，没必要关注！</p><h1 id="第三节：配置-Git"><a href="#第三节：配置-Git" class="headerlink" title="第三节：配置 Git"></a>第三节：配置 Git</h1><p><font color=red><strong>先验知识：Git 的所有配置是以文件的形式存储的！</strong></font></p><h2 id="3-1：Git的配置原理"><a href="#3-1：Git的配置原理" class="headerlink" title="3.1：Git的配置原理"></a>3.1：Git的配置原理</h2><p>Git 的配置分为系统级别、全局级别、项目级别这三个等级：</p><table><thead><tr><th align="center">权重</th><th align="center">中文名</th><th align="center">优先级</th><th align="center">配置文件</th></tr></thead><tbody><tr><td align="center">system</td><td align="center">系统级别</td><td align="center">低</td><td align="center"><code>etc/gitconfig</code></td></tr><tr><td align="center">global</td><td align="center">全局级别</td><td align="center">中</td><td align="center"><code>~/.gitconfig</code></td></tr><tr><td align="center">local</td><td align="center">仓库级别</td><td align="center">高</td><td align="center"><code>.git/config</code></td></tr></tbody></table><p>这三层配置具有不同的优先级，假如在这三个配置文件中定义的值有冲突的话，以优先级高的为准。比如在仓库级别和全局级别中都配置了用户名和邮箱，那么仓库级别的配置将发挥作用！</p><p><font color='red'><strong>Git 的配置文件</strong></font></p><ul><li>系统配置：配置文件一般是<code>/etc/gitcongif</code>，但假如使用的是CLT中内置的Git的话，配置文件是在CLT的安装目录中，具体位置是<code>/Library/Developer/CommandLineTools/usr/share/git-core/gitconfig</code>！</li><li>全局配置：配置文件是<code>~/.gitconfig</code>。默认该文件不存在，除非使用安装程序进行安装并在安装过程中进行全局配置时，才会生成这个文件；如果不是的话，这个文件只有在你第一次进行全局配置时才会自动生成！</li><li>项目配置：配置文件就是项目目录下的<code>.git/config</code>文件。这个文件不会发生变化，不管你是在什么平台上使用什么版本的 Git，项目级别的配置文件都不会发生变化！</li></ul><p><font color='red'><strong>查看 Git 的配置</strong></font></p><p>除了通过上面提到的三个配置文件来查看 Git 的配置以外，还可以使用<code>git config --list</code>来查看。比如我刚安装完命令行工具后、进行全局配置之前，查看 Git 的配置：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143655398.png"></p><h2 id="3-2：配置环境变量"><a href="#3-2：配置环境变量" class="headerlink" title="3.2：配置环境变量"></a>3.2：配置环境变量</h2><p>终端中执<code>git --version</code>命令可以直接输出 Git 版本号，使用<code>which</code>命令可见 Git 的命令是在<code>/usr/bin</code>目录下的，而这个目录本来就在 macOS 的 PATH 环境变量中：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020143836079.png"></p><p>这两点都说明：<font color='red'><strong>使用命令行工具内置的 Git，我们不需要再单独配置环境变量</strong></font>！</p><h2 id="3-3：用户名和邮箱"><a href="#3-3：用户名和邮箱" class="headerlink" title="3.3：用户名和邮箱"></a>3.3：用户名和邮箱</h2><p>对于 Git 而言，用户名和邮箱地址这两条配置很重要，每次使用 Git 提交时都会引用这两条信息，用来说明是谁提交了内容更新，所以会随更新内容一起被永久纳入历史记录！而用户名和邮箱是用户可以任意自定义的，Git 在系统配置中不可能预先设置这两个配置，<font color='red'>所以在使用 Git 之前</font>，<font color='red'>配置用户名和邮箱就是必要的操作</font>！</p><p>Git 允许你设置一个全局的用户名和邮箱，同时也允许你为每个项目设置单独的用户名和邮箱。为了方便使用，我们一般会配置一个全局的，如果有需要的话，再在项目级别配置特殊的用户名和邮箱。</p><p>配置全局用户名和邮箱，使用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name 用户名</span><br><span class="line">git config --global user.email 邮箱地址</span><br></pre></td></tr></table></figure><p>比如我在配置用户名和邮箱时是这样的：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020144159787.png"></p><p>执行了全局配置以后，在用户目录下就会生成<code>.gitconfig</code>的配置文件，文件内容为：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020144359565.png"></p><p>此时再通过<code>git config --list</code>命令来查看 Git 的配置：</p><p><img src="https://www.czblogs.cn/posts/macos/07/image-20231020145010110.png"></p><p>假如要修改用户名和邮箱配置的话，只需要修改全局配置文件的内容即可，当然也可以通过<code>config</code>命令重新设置！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果芯片的macOS安装命令行工具</title>
      <link href="/post/6.html"/>
      <url>/post/6.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：写在前面"><a href="#第一节：写在前面" class="headerlink" title="第一节：写在前面"></a>第一节：写在前面</h1><h2 id="1-1：什么是命令行工具"><a href="#1-1：什么是命令行工具" class="headerlink" title="1.1：什么是命令行工具"></a>1.1：什么是命令行工具</h2><p>命令行工具（Command Line Tools）是 macOS 上至关重要的插件，苹果官方是这么介绍它的：下载 macOS SDK、标题和构建工具（如 Apple LLVM 编译器和 Make），能助您轻松安装开源软件或在终端内的 UNIX 上进行开发。macOS 可以在您首次尝试构建软件时自动下载这些工具，您也可以随时在下载页面找到它们。</p><p>简单地说，命令行工具有两个用处：</p><ul><li><font color='red'>使用Mac电脑终端开发软件</font>；</li><li><font color='red'>让开源软件能够顺利安装</font>；</li></ul><p>简单来说，Command Line Tools 就是一个小型独立包，为 macOS 终端用户提供了很多常用的工具、实用程序和一些编译器，包括但不限于 svn、git、make、gcc、clang、perl、size、strip、cpp、python3…</p><p>在使用 Mac 终端进行开发的时候，需要用到比如 Git 之类的工具！在 macOS 系统中原本就存在一些命令，也就是可执行文件，在<code>/usr/bin</code>目录下的那些常用命令，如 git 和 python3 等，这些命令虽然原本就存在，但是并不能使用！如：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020135808310.png"></p><p>再比如：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020135927169.png"></p><p>这些命令本身就存在，但是在使用的时候，Mac 终端会给出如下提示（此图已经更新过）：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020135947454.png"></p><p>这些工具会在我们安装完命令行开发者工具以后，就能正常使用了！</p><h2 id="1-2：我的-macOS-版本"><a href="#1-2：我的-macOS-版本" class="headerlink" title="1.2：我的 macOS 版本"></a>1.2：我的 macOS 版本</h2><p>我这里安装命令行工具的 macOS 版本是 macOS Sonoma 14.0 版！</p><h1 id="第二节：安装配置"><a href="#第二节：安装配置" class="headerlink" title="第二节：安装配置"></a>第二节：安装配置</h1><p>下载安装 Command Line Tools 有两种方式：</p><ul><li>第一种是去 Apple 开发者网站上去下载，下载之前需要先免费注册成为 Apple 开发者，然后再登陆下载；</li><li>第二种方式就比较简单了，可以通过 Mac 自带的终端，执行命令来安装（国内可能会因为网络问题而失败）；</li></ul><h2 id="2-1：下载安装"><a href="#2-1：下载安装" class="headerlink" title="2.1：下载安装"></a>2.1：下载安装</h2><p>这里我选择使用第二种方式。打开终端，执行如下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xcode-select --install</span><br></pre></td></tr></table></figure><p>按下回车键的时候，终端会给出提示：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140409917.png"></p><p>点击安装，又会弹出协议，点击“同意”：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140557483.png"></p><p>然后会自动查找软件：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140734927.png"></p><p>查找到以后，就自动下载了：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140805381.png"></p><p>刚开始展示的下载时间很长，但是网络好的话，很快就展示真实的下载时长了：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020140924113.png"></p><p>下载完成后会自动安装：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020141134095.png"></p><p>待安装完成后，点击“完成”即可：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020141405504.png"></p><h2 id="2-2：安装位置"><a href="#2-2：安装位置" class="headerlink" title="2.2：安装位置"></a>2.2：安装位置</h2><p>原本在<code>/Library</code>目录下，以<code>D</code>开头的目录只有<code>DirectoryServices</code>、<code>Documentation</code>、<code>DriverExtensions</code>！</p><p>安装完以后，就会在<code>/Library</code>下生成名为<code>/Developer/CommandLineTools</code>的目录，目录中的内容如下：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142024664.png"></p><p>这些都是新生成的目录，其中三个子文件夹：</p><ul><li><code>Library</code>：安装的依赖库，我这里只能看到 python 的依赖库；</li><li><code>SDKs</code>：Apple APP 开发依赖的开发环境；</li><li><code>usr</code>：这个文件夹的内容是很多的，在它里面有很多的命令和依赖等，主要是 gcc、pip3、git 等等；</li></ul><p>注意：在这里的<code>/CommandLineTools/Library/Frameworks/Python3.framework/Versions</code>中安装了 python3 ！</p><h2 id="2-3：环境变量"><a href="#2-3：环境变量" class="headerlink" title="2.3：环境变量"></a>2.3：环境变量</h2><p>在没安装命令行工具之前，macOS 的环境变量为(此图已经更新)：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142129128.png"></p><p>而安装完以后，macOS的环境变量为：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142306822.png"></p><p>可见此时系统环境变量实际上并没有什么变化！而且此时可以直接使用<code>/usr/bin</code>目录下的命令，而不用配置环境变量！</p><h2 id="2-4：个人思考"><a href="#2-4：个人思考" class="headerlink" title="2.4：个人思考"></a>2.4：个人思考</h2><p>安装完命令行开发工具以后，我们在终端中就能使用这些命令了：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142434564.png"></p><p>首先，我们先来看一下在终端中使用的这些命令来自哪里：</p><p><img src="https://www.czblogs.cn/posts/macos/06/image-20231020142515905.png"></p><p>查看安装命令行工具前后 macOS 的 PATH 变量和指定文件，发现没有任何变化！最重要的是，查看命令行开发者工具目录中的这些命令，他们也没有指向<code>/usr/bin/</code>目录中的那些命令；同时<code>/usr/bin</code>中那些系统原本就存在但是无法使用的命令也没指向 CLT 中安装的命令！那就很奇怪了，为什么在<code>/Library/Developer/CommandLineTools/</code>中安装的这些命令可以被终端找到并使用呢？？？</p><p>其实这里就没必要关注这个问题了，即然 Mac 在<code>/usr/bin</code>目录中预留了<code>python3</code>和<code>pip3</code>等命令（虽然不能默认是不能使用的），而且命令行开发者工具又是为 macOS 量身定做，那么他们肯定在我们不得知的地方进行了特殊的处理，所以它就把<code>/Library/Developer/CommandLineTools/</code>目录中安装的这些命令都映射到了<code>/usr/bin</code>目录中原本存在的这些命令上了！</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> Command Line Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>苹果芯片的macOS安装配置VSCode</title>
      <link href="/post/5.html"/>
      <url>/post/5.html</url>
      
        <content type="html"><![CDATA[<h1 id="第一节：下载和安装"><a href="#第一节：下载和安装" class="headerlink" title="第一节：下载和安装"></a>第一节：下载和安装</h1><p>浏览器访问 VSCode 的<a href="https://code.visualstudio.com/">官网</a>，点击页面的下载链接：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020125527693.png"></p><p>下载下来的是一个<code>.app</code>格式的安装程序：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020125800526.png"></p><p>最后直接将这个文件拖动到应用程序文件夹中即可完成安装，之后从启动台来启动VSCode即可！</p><h1 id="第二节：自定义设置"><a href="#第二节：自定义设置" class="headerlink" title="第二节：自定义设置"></a>第二节：自定义设置</h1><h2 id="2-1：语言设置"><a href="#2-1：语言设置" class="headerlink" title="2.1：语言设置"></a>2.1：语言设置</h2><p>刚启动 VSCode 时，右下角会提示是否要切换到简体中文，点击“安装并重启”，稍等片刻即可切换语言为简体中文！</p><h2 id="2-2：用户登录"><a href="#2-2：用户登录" class="headerlink" title="2.2：用户登录"></a>2.2：用户登录</h2><p>VSCode 支持用户登陆，登陆用户可以同步自己的个性化设置，所以在设置之前最好登陆一下，然后以后每次重新安装的时候就不用重复设置了，只需要登陆即可。</p><p>点击左下角的头像按钮，选择“备份和同步设置…”，然后点击顶部的<code>登陆</code>：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020130801735.png"></p><p>最后选择使用 Github 账号或者 Microsoft 账号登陆都可以，在弹出的网页上输入账号和密码并点击登陆，当展示：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131231669.png"></p><p>则表示登陆成功，此时右下角会展示：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131327709.png"></p><h2 id="2-3：受信任区"><a href="#2-3：受信任区" class="headerlink" title="2.3：受信任区"></a>2.3：受信任区</h2><p>在 VSCode 中有“受信任区”这么个说法，所谓受信任区，简单理解就是 VSCode 可以访问和编辑的文件目录，假如使用 VSCode 打开非信任区的文件时，总是会给出提示：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131517298.png"></p><p>我们需要将本机所有的目录都放到信任区中，这样以后使用 VSCode 打开任意位置的文件时，就不会有警告了！</p><p>点击左下角的盾牌图标，接着点击<code>添加文件夹</code>：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131609871.png"></p><p>然后把本机根目录<code>/</code>添加进去：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020131715183.png"></p><p>然后直接关闭这个页面，即可完成设置！</p><h2 id="2-4：字体相关"><a href="#2-4：字体相关" class="headerlink" title="2.4：字体相关"></a>2.4：字体相关</h2><p>VSCode 的字体有两种，一是页面 UI 字体，二是编辑区的字体！我们可以通过<code>command</code>和<code>-</code>或<code>+</code>来调整界面 UI 字体大小，而对于编辑区的默认字体，需要打开设置，依次选择“文本编辑器” –&gt; “字体”：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020132806018.png"></p><p>还可以通过 Ctrl 和鼠标滚轮的组合来灵活修改编辑区字体。在设置页面搜索“Mouse Wheel Zoom”：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020132922757.png"></p><h2 id="2-5：Tab-Size"><a href="#2-5：Tab-Size" class="headerlink" title="2.5：Tab Size"></a>2.5：Tab Size</h2><p>在文本编辑器中，尤其是使用 VSCode 编辑代码时，我们一般会使用 Tab 键来执行缩进操作。但是 Tab 键有时候虽然看起来是缩进了 4 个空格，但是它在编码上并不代表 4 个空格。所以这里我们设置一下，设置后的效果就是：每当键入 Tab 时，都能不多不少地正确输入 4 个空格（但是假如你经常使用 VSCode 来编辑前段代码，那最好是设置为 2 个空格）！</p><p>第一步：设置一个制表符代表的空格数是 2。打开设置，搜索“Tab Size”，将一个制表符等于的空格数设置为 2：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133228428.png"></p><p>第二步：关闭“Detect Indentation”。假如不关闭的话，VSCode 会根据文件内容自动推测 Tab 的空格数：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133412652.png"></p><h2 id="2-6：控制字符"><a href="#2-6：控制字符" class="headerlink" title="2.6：控制字符"></a>2.6：控制字符</h2><p>VSCode 的编辑页面默认会隐藏空格等字符（其他编辑器基本也是这样），但我使用它主要是用来看代码的，所以我希望可以在编辑区展示包括空格在内的所有字符！</p><p>第一步：打开设置后搜索“Render Control Characters”，进行如下设置</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133555571.png"></p><p>第二步：搜索“Render Whitespace”，将这一项的默认值由 selection 设置为 all</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133756686.png"></p><h1 id="第三节：个性化插件"><a href="#第三节：个性化插件" class="headerlink" title="第三节：个性化插件"></a>第三节：个性化插件</h1><h2 id="3-1：文件图标"><a href="#3-1：文件图标" class="headerlink" title="3.1：文件图标"></a>3.1：文件图标</h2><p>当使用 VSCode 打开文件夹时，上级目录展示的图标都是箭头：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133805147.png"></p><p>我们可以安装插件，让文件的图标更形象化，我使用的插件是<code>vscode-icons-mac</code>。打开插件市场搜索它：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020133947951.png"></p><p>点击安装，安装完成以后，可见效果：</p><p><img src="https://www.czblogs.cn/posts/macos/05/image-20231020134043705.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> macOS </tag>
            
            <tag> VSCode </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
    
    <entry>
      <title>404</title>
      <link href="/404.html"/>
      <url>/404.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>关于我</title>
      <link href="/about/index.html"/>
      <url>/about/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>分类</title>
      <link href="/categories/index.html"/>
      <url>/categories/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>优秀链接</title>
      <link href="/link/index.html"/>
      <url>/link/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>图片展</title>
      <link href="/images/index.html"/>
      <url>/images/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>comment</title>
      <link href="/comment/index.html"/>
      <url>/comment/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>标签</title>
      <link href="/tags/index.html"/>
      <url>/tags/index.html</url>
      
        <content type="html"><![CDATA[]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>电影院</title>
      <link href="/movies/index.html"/>
      <url>/movies/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
    
    <entry>
      <title>音乐汇</title>
      <link href="/music/index.html"/>
      <url>/music/index.html</url>
      
        <content type="html"><![CDATA[<h1 id="页面建设中"><a href="#页面建设中" class="headerlink" title="页面建设中"></a>页面建设中</h1>]]></content>
      
    </entry>
    
    
  
</search>
